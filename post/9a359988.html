<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>树专题实验 | Ann の 小窝</title><meta name="keywords" content="树"><meta name="author" content="A-624"><meta name="copyright" content="A-624"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="实验题目： 平衡树搜索性能比较 [TOC] 实验目的 熟悉二叉搜索树以及常用的平衡树结构，对不同树搜索过程的时间复杂度有直观的认识 实验内容 实验说明  实验环境为c++，vscode 1.73.1，检查运行不需要添加外部依赖 五个源文件分别记录五棵树的实现，在宏定义部分设置随机生成数的数量和大小，请保证max不小于初始生成树的节点数量。另外，除了result等临时数组，所有的数组都是从下标1开始">
<meta property="og:type" content="article">
<meta property="og:title" content="树专题实验">
<meta property="og:url" content="https://a-624.github.io/post/9a359988.html">
<meta property="og:site_name" content="Ann の 小窝">
<meta property="og:description" content="实验题目： 平衡树搜索性能比较 [TOC] 实验目的 熟悉二叉搜索树以及常用的平衡树结构，对不同树搜索过程的时间复杂度有直观的认识 实验内容 实验说明  实验环境为c++，vscode 1.73.1，检查运行不需要添加外部依赖 五个源文件分别记录五棵树的实现，在宏定义部分设置随机生成数的数量和大小，请保证max不小于初始生成树的节点数量。另外，除了result等临时数组，所有的数组都是从下标1开始">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://w.wallhaven.cc/full/gp/wallhaven-gpzve7.png">
<meta property="article:published_time" content="2022-11-19T00:46:08.000Z">
<meta property="article:modified_time" content="2022-11-24T01:35:11.186Z">
<meta property="article:author" content="A-624">
<meta property="article:tag" content="树">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://w.wallhaven.cc/full/gp/wallhaven-gpzve7.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://a-624.github.io/post/9a359988"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: {"appId":"YD8D4MBDZ4","apiKey":"cae15c3362dd9749a20b9f3989daccd4","indexName":"blog","hits":{"per_page":6},"languages":{"input_placeholder":"搜索文章","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '树专题实验',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-11-24 09:35:11'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/rightMenu.css"><link rel="stylesheet" href="/css/custom.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/swiper/swiper-bundle.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/js-heo@1.0.11/bb/showbb_in_index.css"><link rel="stylesheet" href="/css/bber.css"><link rel="stylesheet" href="/css/background.css"><link rel="stylesheet" href="https://unpkg.com/swiper/swiper-bundle.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-card-history/baiduhistory/css/main.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-butterfly-categories-card/lib/categorybar.css"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@1.0.17/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-filter-gitcalendar/lib/gitcalendar.css" media="print" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="wizard-scene"><div class="wizard-objects"><div class="wizard-square"></div><div class="wizard-circle"></div><div class="wizard-triangle"></div></div><div class="wizard"><div class="wizard-body"></div><div class="wizard-right-arm"><div class="wizard-right-hand"></div></div><div class="wizard-left-arm"><div class="wizard-left-hand"></div></div><div class="wizard-head"><div class="wizard-beard"></div><div class="wizard-face"><div class="wizard-adds"></div></div><div class="wizard-hat"><div class="wizard-hat-of-the-hat"></div><div class="wizard-four-point-star --first"></div><div class="wizard-four-point-star --second"></div><div class="wizard-four-point-star --third"></div></div></div></div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/favicon.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 碎碎念</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child" style="right:-90px"><li><a class="site-page child" href="/ispeaker/"><i class="fa-fw fas fa-paper-plane"></i><span> 日志</span></a></li><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fas fa-tags"></i><span> 说说</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 工具箱</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Ann の 小窝</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 碎碎念</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child" style="right:-90px"><li><a class="site-page child" href="/ispeaker/"><i class="fa-fw fas fa-paper-plane"></i><span> 日志</span></a></li><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fas fa-tags"></i><span> 说说</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 工具箱</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">树专题实验</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-11-19T00:46:08.000Z" title="发表于 2022-11-19 08:46:08">2022-11-19</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-11-24T01:35:11.186Z" title="更新于 2022-11-24 09:35:11">2022-11-24</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/expriment/">expriment</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">19.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>79分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="树专题实验"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><h1>实验题目： 平衡树搜索性能比较</h1>
<p>[TOC]</p>
<h2 id="实验目的">实验目的</h2>
<p>熟悉二叉搜索树以及常用的平衡树结构，对不同树搜索过程的时间复杂度有直观的认识</p>
<h2 id="实验内容">实验内容</h2>
<h3 id="实验说明">实验说明</h3>
<ol>
<li>实验环境为c++，vscode 1.73.1，检查运行不需要添加外部依赖</li>
<li><strong>五个源文件</strong>分别记录五棵树的实现，在<strong>宏定义部分设置随机生成数的数量和大小</strong>，请保证<strong>max不小于初始生成树的节点数量</strong>。另外，除了result等临时数组，所有的<strong>数组都是从下标1开始</strong>。</li>
<li>update_file函数是进行源数据的更新操作，注释掉也没有关系，详见实验报告</li>
<li><strong>实验检查</strong>（插入1000减去950，并中序遍历，和后五十个数组的排序结果对比等要求）被集中到了测试函数<code>insert_1000_test</code>中，<strong>直接运行即可</strong>在终端看到输出。</li>
<li>试验检查后的create函数是新的树，然后会<strong>显示菜单栏</strong>进行下一步的选择，不需要您额外操作。</li>
<li>本次实验允许重复值的插入，并对数组中每一个元素都进行了<strong>唯一的id编号</strong>，在删除和查找操作中会有显示，<strong>允许指定id的数据删除</strong>。</li>
<li>设置全局变量flag，如果想要实现网页上的效果，即仅查找到第一个元素，或者<strong>仅删除查找到的第一个元素</strong>，可以<strong>将flag设为1</strong>。</li>
<li>可视化检查参考网站：<a target="_blank" rel="noopener" href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html%E3%80%82%E9%99%A4%E4%BA%86%E4%BA%8C%E5%8F%89%E6%A0%91%E6%B2%A1%E6%9C%89%E6%9B%B4%E6%94%B9%E5%89%8D%E9%A9%B1%E5%90%8E%E7%BB%A7%E7%9A%84%E9%80%89%E6%8B%A9%EF%BC%8C%E5%85%B6%E4%BD%99%E5%9D%87%E6%8C%89%E7%85%A7%E7%BD%91%E7%AB%99%E5%86%85%E5%AE%B9%E7%BC%96%E7%A8%8B%E3%80%82%E9%83%A8%E5%88%86%E8%87%AA%E5%B7%B1%E9%80%89%E6%8B%A9id%E5%88%A0%E9%99%A4%E7%9A%84%E5%86%85%E5%AE%B9%E9%99%A4%E5%A4%96%E3%80%82">https://www.cs.usfca.edu/~galles/visualization/Algorithms.html。除了二叉树没有更改前驱后继的选择，其余均按照网站内容编程。部分自己选择id删除的内容除外。</a></li>
</ol>
<h3 id="通用函数介绍">通用函数介绍</h3>
<p><strong>文件生成函数</strong>：</p>
<ul>
<li>每个树都有一个txt源文件，和lab1基本一致</li>
<li>主函数中<code>update_file（）</code>用于txt文件的更新，数量是max</li>
<li><code>init_byfile()</code>将文件中的数字<strong>写入数组</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> max 30 <span class="comment">//初始化源数据的数量</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxran 50 <span class="comment">//限制数的大小</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">update_file</span><span class="params">()</span>&#123;</span><br><span class="line">    ofstream f;</span><br><span class="line">    f.open(<span class="string">&quot;tree_data.txt&quot;</span>,ios::trunc);<span class="comment">//文件名在这里进行替换</span></span><br><span class="line">    srand((<span class="type">int</span>)time(<span class="number">0</span>)); <span class="comment">// 产生随机种子</span></span><br><span class="line">    f &lt;&lt; (rand()%(maxran)+<span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; max<span class="number">-1</span>; i++)</span><br><span class="line">        f&lt;&lt;<span class="string">&quot; &quot;</span> &lt;&lt; (rand()%(maxran)+<span class="number">1</span>) ;</span><br><span class="line">    f.close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">init_byfile</span><span class="params">(<span class="type">float</span> ta[])</span> &#123; </span><br><span class="line">    ifstream <span class="title function_">f</span><span class="params">(<span class="string">&quot;tree_data.txt&quot;</span>)</span>;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!f.eof()) &#123;f&gt;&gt;ta[i++];&#125;</span><br><span class="line">    f.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>显示函数</strong>：</p>
<ol>
<li>初始<strong>菜单</strong>，用来显示可执行的功能，且都差不多</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">welcome</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;please input the number to choose the function&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;1:insert new node&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;2:delete  node&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;3:search the node&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;4:print the tree state&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;5:exit the programe&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>树<strong>打印函数</strong>，可能在不同题目中略有不同，比如在平衡树中额外打印每个节点的<code>weight</code>等，以及大于两个子树的b树等，只需要修改显示内容，以及递归条件稍作变化，此处仅列举一个。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//打印操作</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printBT</span><span class="params">(<span class="type">const</span> <span class="built_in">string</span> pre,bitnode *node, <span class="type">bool</span> isLeft)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; pre;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;(isLeft?<span class="string">&quot;├──&quot;</span> : <span class="string">&quot;└──&quot;</span>);<span class="comment">//三个字符</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; node-&gt;data &lt;&lt;<span class="string">&quot;(id=&quot;</span>&lt;&lt;node-&gt;index&lt;&lt;<span class="string">&quot;)&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        printBT(pre+(isLeft ? <span class="string">&quot;│   &quot;</span> : <span class="string">&quot;    &quot;</span>), node-&gt;lchild, <span class="literal">true</span>);<span class="comment">//左子树之后要输出&quot;|&quot;用于表示连接右子树的线，以及总长度应该是四个字符</span></span><br><span class="line">        printBT(pre+(isLeft ? <span class="string">&quot;│   &quot;</span> : <span class="string">&quot;    &quot;</span>), node-&gt;rchild, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">print_tree</span><span class="params">(bitree L)</span> &#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="string">&quot;tree&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    printBT	( <span class="string">&quot;&quot;</span>, L, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>左子树或者非右子树放在<strong>上侧</strong>，pre用于记录每一层的空格等，每次先输出空格和连接线，然后判断节点是否为最右节点，输出节点前的分支符号，每一次输出则下一层的pre都要有前面的连接线，递归打印即可。</p>
<p>注意，之所以不使用c语言的字符串数组，是因为不能直接赋值，且需要提前分配空间等。较麻烦，故采用了c++的string类型进行pre的设置。</p>
</blockquote>
<p><strong>树相关</strong>：</p>
<p>树的初始化和销毁函数是一致的，后面的子树销毁只需要在递归的时候使用for循环即可。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">initbitree</span><span class="params">(bitree &amp;L)</span>&#123;</span><br><span class="line">    L=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">destroybitree</span><span class="params">(bitree &amp;L)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!L) <span class="keyword">return</span>;<span class="comment">//the leaves just skip</span></span><br><span class="line">    <span class="keyword">if</span>(L-&gt;lchild) destroybitree(L-&gt;lchild);</span><br><span class="line">    <span class="keyword">if</span>(L-&gt;rchild) destroybitree(L-&gt;rchild);</span><br><span class="line">    delete L;</span><br><span class="line">    L=<span class="literal">NULL</span>;<span class="comment">//T-&gt;lchild=NULL</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="（一）二叉搜索树">（一）二叉搜索树</h3>
<h4 id="实验要求："><strong>实验要求</strong>：</h4>
<p>给定一个n元素的实数数组，构建二叉搜索树，实现节点的插入删除和搜索功能</p>
<h4 id="实验内容："><strong>实验内容</strong>：</h4>
<ol>
<li>数据结构
<ul>
<li>初始数组的下标是从1开始的</li>
<li><code>since_index</code>是设置的全局变量，用于给每一个节点包括新插入的节点一个唯一的id，和数组对应从1开始，自己添加的节点则顺延 id</li>
</ul>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">bitnode</span>&#123;</span></span><br><span class="line">    <span class="type">float</span> data;</span><br><span class="line">    <span class="type">int</span> index;<span class="comment">//表示唯一的标识</span></span><br><span class="line">    bitnode* lchild,*rchild;</span><br><span class="line">&#125;*bitree;</span><br><span class="line"><span class="type">int</span> since_index=<span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><strong>创建</strong>：依据已经有的数组a[n]构建二叉搜索树
<ul>
<li><strong>初始</strong>化二叉树，调用<code>initbitree(L)</code></li>
<li>遍历数组，<strong>先申请新的节点空间</strong>，设置信息，由于一定插入到叶子节点，新节点的<strong>后继均为NULL</strong>，然后调用插入节点函数
<ul>
<li>插入位置如果为空，直接将节点赋值</li>
<li><strong>插入元素</strong>如果<strong>小于头结点</strong>，则递归插入左子树</li>
<li>同理如果<strong>大于等于</strong>头结点，递归插入右子树</li>
</ul>
</li>
<li>在寻找<strong>左右孩子</strong>的过程中，一定找得到一个空位置，此时直接将这个<strong>孩子指针</strong>赋值成<strong>插入节点的指针</strong>即可。</li>
</ul>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//建立二叉树</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insert</span><span class="params">(bitree &amp;L,bitree a)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!L) &#123;L=a;<span class="keyword">return</span>;&#125;<span class="comment">//注意！L是上一层节点的孩子或者头结点，这里的效果和L1-&gt;child=p是一样的</span></span><br><span class="line">    <span class="keyword">if</span> (a-&gt;data&lt;L-&gt;data) &#123;</span><br><span class="line">        insert(L-&gt;lchild,a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a-&gt;data&gt;=L-&gt;data) &#123;</span><br><span class="line">        insert(L-&gt;rchild,a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">createbitree</span><span class="params">(bitree &amp;T,<span class="type">float</span> a[],<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    bitree p;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">        p=new bitnode;</span><br><span class="line">        p-&gt;data=a[i];</span><br><span class="line">        p-&gt;index=since_index;</span><br><span class="line">        p-&gt;lchild=<span class="literal">NULL</span>;</span><br><span class="line">        p-&gt;rchild=<span class="literal">NULL</span>;<span class="comment">//信息复制</span></span><br><span class="line">        insert(T,p);since_index++;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>新元素的<strong>插入</strong></li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//插入操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertbyuser</span><span class="params">(bitree &amp;L)</span></span>&#123;</span><br><span class="line">    bitree temp=<span class="keyword">new</span> bitnode;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;data:&quot;</span>&lt;&lt;endl;</span><br><span class="line">    cin&gt;&gt;temp-&gt;data;</span><br><span class="line">    temp-&gt;index=since_index++;</span><br><span class="line">    temp-&gt;lchild=<span class="literal">NULL</span>;</span><br><span class="line">    temp-&gt;rchild=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">insert</span>(L,temp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>元素<strong>搜索</strong>
<ul>
<li>利用二叉搜索树的特性搜索<strong>给定值</strong>，<strong>返回 id</strong>，如果来自于数组，则<strong>id为数组下标</strong></li>
<li><strong>新建变量</strong>指针数组<code>result[10]</code>用于存储搜索结果，如果初始化n很大，可以更改其定义，同时新建变量<code>resultnum</code>表示相同值的数量</li>
<li>调用<strong>搜索</strong>函数
<ul>
<li>搜索节点和头结点<strong>比较</strong>，如果小于头结点则<strong>递归搜索左子树</strong>，反之递归搜索右子树</li>
<li>flag=0时，在查找到结果之后并不返回，而是将结果存在数组中，并且继续检查<strong>右子树</strong>中是否有相同值。（创建时大于等于的数放在右子树）直到遍历到<strong>叶子节点</strong>，其子节点为空，符合递归出口</li>
<li>flag=1时，查找到结果直接返回上一级，由于每次递归都是返回即回溯，故直接得到结果。</li>
</ul>
</li>
</ul>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//搜索</span></span><br><span class="line"><span class="type">void</span>  <span class="title function_">search_node</span><span class="params">(bitree L,<span class="type">float</span> temp,bitree result[],<span class="type">int</span> &amp;resultnum)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!L) &#123;<span class="keyword">return</span> ;&#125;</span><br><span class="line">    <span class="keyword">if</span>(L-&gt;data==temp)&#123;</span><br><span class="line">        result[resultnum++]=L;</span><br><span class="line">        <span class="keyword">if</span>(flag) <span class="keyword">return</span>;<span class="comment">//如果找到结果直接返回到上一级</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span>(temp&lt;L-&gt;data)  search_node(L-&gt;lchild,temp,result,resultnum);</span><br><span class="line">    <span class="keyword">else</span>  search_node(L-&gt;rchild,temp,result,resultnum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">researchbyuser</span><span class="params">(bitree &amp;L)</span>&#123;</span><br><span class="line">    <span class="type">float</span> temp;</span><br><span class="line">    <span class="type">int</span> id,resultnum=<span class="number">0</span>;<span class="comment">//搜索到的元素数量</span></span><br><span class="line">    bitree result[<span class="number">10</span>];<span class="comment">//假设重复元素不多，如果要较真的话，可以用max进行动态分配</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;data:&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;temp;</span><br><span class="line">    search_node(L,temp,result,resultnum);</span><br><span class="line">    <span class="keyword">if</span>(!resultnum) <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;not exist&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(id=<span class="number">0</span>;id&lt;resultnum;id++) </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;the id of the search node  &quot;</span>&lt;&lt;result[id]-&gt;index&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>元素<strong>删除</strong>
<ul>
<li>首先<strong>输入</strong>需要删除的值的大小，调用搜索函数进行查找</li>
<li>如果值<strong>不存在</strong>，直接返回报错</li>
<li>如果只有一个值，则调用删除函数进行删除，<strong>多个值</strong>则先将index打印出来，然后由操作者决定删除几个，<strong>依次输入对应的index</strong>即可删除</li>
<li><strong>删除函数</strong>的思路
<ul>
<li><strong>定位p的父节点</strong>（利用二叉搜索树性质）
<ul>
<li>设置<strong>当前节点</strong><code>temp=L</code>与 p 的值比较</li>
<li>当前节点大于p，则<strong>p是temp的左孩子，或者孙子等</strong></li>
<li>将p和<code>temp-&gt;lchild</code>比较，如果是，则找到父节点，如果不是，将<strong>当前节点</strong>移动到其左孩子，继续和p比较大小，直到<strong>当前节点</strong>到达根节点</li>
</ul>
</li>
<li>如果删除节点<strong>至少有一个为空节点</strong>，直接将父节点的后继设置为下一个节点。该情况包括了<strong>均为空节点</strong>的情况。特别的，如果<strong>删除的是头结点</strong>，则需要另外对L进行赋值。</li>
<li>如果左右孩子<strong>均不为空</strong>，我们直接搜索右子树的<strong>最左节点</strong>，然后将本节点和最左节点交换信息，然后删除最左节点即可，<strong>最左节点至少有一个空节点孩子</strong>，回到上面的情况。</li>
<li><strong>注意</strong>！！！在寻找前驱的时候，有一种可能是最左子树的最右节点就是本节点的得左节点，此时继承语句应该是p-&gt;lchild 而不是q-&gt;rchild，这一点后面的树也会提及。</li>
</ul>
</li>
</ul>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除</span></span><br><span class="line">bitree <span class="title function_">get_parent</span><span class="params">(bitree L,bitree p)</span>&#123;</span><br><span class="line">    bitree temp=L,parent;<span class="comment">//temp设置为目前指针</span></span><br><span class="line">    <span class="keyword">while</span>(temp!=<span class="literal">NULL</span> &amp;&amp;temp!=p)&#123;</span><br><span class="line">        <span class="keyword">if</span>(temp-&gt;data&gt;p-&gt;data)&#123;<span class="comment">//目前指针的值比p大，p可能是目前指针的左孩子</span></span><br><span class="line">            parent=temp;</span><br><span class="line">            temp=temp-&gt;lchild;<span class="comment">//如果temp==p，则parent即所求父节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;<span class="comment">//右孩子有大于等于的可能性</span></span><br><span class="line">            parent=temp;</span><br><span class="line">            temp=temp-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> parent;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除一个节点</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delete_one_value</span><span class="params">(bitree&amp;L,bitree p)</span>&#123;</span><br><span class="line">    bitree q=get_parent(L,p);<span class="comment">//工具人</span></span><br><span class="line">    bitree max_left;<span class="comment">//最左节点</span></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;lchild==<span class="literal">NULL</span>)&#123;<span class="comment">//右节点是空节点</span></span><br><span class="line">        <span class="keyword">if</span>(p==L) L=L-&gt;rchild;<span class="comment">//如果是根节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(q-&gt;lchild==p)  q-&gt;lchild=p-&gt;rchild;</span><br><span class="line">        <span class="keyword">else</span> q-&gt;rchild=p-&gt;rchild;</span><br><span class="line">        delete p;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(p-&gt;rchild==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p==L) L=L-&gt;lchild;<span class="comment">//如果是根节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(q-&gt;lchild==p)  q-&gt;lchild=p-&gt;lchild;</span><br><span class="line">        <span class="keyword">else</span> q-&gt;rchild=p-&gt;lchild;</span><br><span class="line">        delete p;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">//有左右子树</span></span><br><span class="line">        max_left=p-&gt;rchild;</span><br><span class="line">        q=p;</span><br><span class="line">        <span class="keyword">while</span>(max_left-&gt;lchild)&#123;<span class="comment">//找到右子树的最左节点</span></span><br><span class="line">            q=max_left;</span><br><span class="line">            max_left=max_left-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;data=max_left-&gt;data;<span class="comment">//交换节点的值，这里可以自己写个函数</span></span><br><span class="line">        p-&gt;index=max_left-&gt;index;</span><br><span class="line">        <span class="keyword">if</span>(q-&gt;lchild==max_left) q-&gt;lchild=max_left-&gt;rchild;</span><br><span class="line">        <span class="keyword">else</span> q-&gt;rchild=max_left-&gt;rchild;<span class="comment">//最左节点可能有右节点</span></span><br><span class="line">        delete max_left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//用户删除节点的总函数，交互功能更多</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">deletebyuser</span><span class="params">(bitree &amp;L)</span>&#123;</span><br><span class="line">    bitree result[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span> resultnum=<span class="number">0</span>,choice,i,id,j=<span class="number">0</span>;<span class="comment">//choice to decide num of deleteones</span></span><br><span class="line">    <span class="type">float</span> temp;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot; please enter the delete value:&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;temp;</span><br><span class="line">    search_node(L,temp,result,resultnum);</span><br><span class="line">    <span class="keyword">if</span>(!resultnum) &#123;<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;is not exist&quot;</span>&lt;&lt;<span class="built_in">endl</span>;<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span>(resultnum==<span class="number">1</span>) &#123; delete_one_value(L,result[j]);<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="comment">//搜索的结果不止一个</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;there are more than one element &quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;resultnum;i++) <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;index: &quot;</span>&lt;&lt;result[i]-&gt;index&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;how many nodes you want to delete&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;i;</span><br><span class="line">        <span class="keyword">for</span>(i;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;id:&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="built_in">cin</span>&gt;&gt;id;</span><br><span class="line">            <span class="keyword">while</span>(id!=result[j]-&gt;index)j++;</span><br><span class="line">            delete_one_value(L,result[j]);</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol start="5">
<li>主函数的设置
<ul>
<li>使用<strong>循环</strong>打印菜单，根据输入数字的不同跳转到不同功能函数</li>
<li>其他包括初始化和善后功能的代码不做展示，在源码中可以查看</li>
</ul>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">       welcome();</span><br><span class="line">       <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;option:&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">       <span class="built_in">cin</span> &gt;&gt; op;</span><br><span class="line">       <span class="keyword">if</span>(op==<span class="number">5</span>) <span class="keyword">break</span>;</span><br><span class="line">       <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">       <span class="keyword">case</span> <span class="number">1</span>:insertbyuser(L);<span class="keyword">break</span>;</span><br><span class="line">       <span class="keyword">case</span> <span class="number">2</span>:deletebyuser(L);<span class="keyword">break</span>;</span><br><span class="line">       <span class="keyword">case</span> <span class="number">3</span>:researchbyuser(L);<span class="keyword">break</span>;</span><br><span class="line">       <span class="keyword">case</span> <span class="number">4</span>:print_tree(L);<span class="keyword">break</span>;</span><br><span class="line">       &#125;      </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="实验效果"><strong>实验效果</strong></h4>
<p>初始化30个100以内的数</p>
<ol>
<li>
<p>菜单</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="assets/image-20221029004033973.png" alt="image-20221029004033973" style="zoom:67%;" />
</li>
<li>
<p>打印树</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="assets/image-20221029004118889.png" alt="image-20221029004118889" style="zoom:67%;" />
</li>
<li>
<p>搜索节点</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="assets/image-20221029004144946.png" alt="image-20221029004144946" style="zoom:67%;" />
</li>
<li>
<p>删除节点</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="assets/image-20221029004518880.png" alt="image-20221029004518880" style="zoom:67%;" />
</li>
<li>
<p>重新打印观察</p>
</li>
</ol>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="assets/image-20221029004557823.png" alt="image-20221029004557823" style="zoom:67%;" />
<ol start="6">
<li>
<p>插入节点</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="assets/image-20221029004730702.png" alt="image-20221029004730702" style="zoom:67%;" />
</li>
</ol>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="assets/image-20221029004805478.png" alt="image-20221029004805478" style="zoom:67%;" />
<h4 id="时间复杂度分析"><strong>时间复杂度分析</strong></h4>
<blockquote>
<p>由于书中有详细介绍故此处不赘述</p>
</blockquote>
<ul>
<li>构造时排序，平均时间复杂度为O（nlogn），最差为O(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">n^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>​)，可以通过随机化建立二叉搜索树来尽量的避免这种情况， 但是在进行了多次的操作之后， 由于在删除时， 我们总是选择将待删除节点的前驱代替它本身， 这样就会造成总是左边的节点数目减少， 以至于平衡性受到破坏， 提高它的操作的时间复杂度</li>
<li>插入，最差O(n)，平均为 O(logn)</li>
<li>搜索，最坏单支，O(n)，平均为 O(logn)</li>
<li>删除，最差O(n)，平均为 O(logn)</li>
</ul>
<h3 id="（二）AVL树">（二）AVL树</h3>
<h4 id="实验要求：-2"><strong>实验要求</strong>：</h4>
<p>给定一个n元素的实数数组，构建AVL树，实现节点的插入删除和搜索功能</p>
<h4 id="实验内容：-2"><strong>实验内容</strong>：</h4>
<ol>
<li><strong>数据结构</strong>
<ul>
<li>在二叉搜索树的基础上，添加平衡因子<code>weight</code>，而由于平衡因子是一个相对值，我们增设节点高度<code>height</code>来辅助计算和后面平衡树的维持</li>
<li>为了直观，<strong>打印</strong>的时候，将每个节点的weight和height打印出来，注意：<strong>左子树在上！</strong></li>
</ul>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">bitnode</span>&#123;</span></span><br><span class="line">    <span class="type">float</span> data;</span><br><span class="line">    <span class="type">int</span> index;<span class="comment">//表示唯一的标识,从零开始计算</span></span><br><span class="line">    <span class="type">int</span> weight;<span class="comment">//平衡因子</span></span><br><span class="line">    <span class="type">int</span> height;</span><br><span class="line">    bitnode* lchild,*rchild;</span><br><span class="line">&#125;*avltree;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>
<p><strong>创建</strong>avl树</p>
<ol>
<li>
<p>树的节点高度和平衡因子更新</p>
<ul>
<li>节点<strong>高度</strong>只需要给定当前节点即可，向下递归到叶子结点后回溯可以得到高度</li>
<li>节点平衡因子需要<strong>后序遍历</strong>二叉树，因为需要先给<strong>叶子节点</strong>计算高度后，才能逐层往上计算平衡因子（相对值）</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">get_height</span><span class="params">(avltree p)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!p) &#123;<span class="keyword">return</span> <span class="number">0</span>;&#125;<span class="comment">//空树，一般不可能</span></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;lchild==<span class="literal">NULL</span>&amp;&amp;p-&gt;rchild==<span class="literal">NULL</span>)&#123;p-&gt;height=<span class="number">1</span>; <span class="keyword">return</span> <span class="number">1</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span>(get_height(p-&gt;lchild)&gt;get_height(p-&gt;rchild))&#123;p-&gt;height=p-&gt;lchild-&gt;height+<span class="number">1</span>;<span class="keyword">return</span> p-&gt;height;&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;p-&gt;height=p-&gt;rchild-&gt;height+<span class="number">1</span>;<span class="keyword">return</span> p-&gt;height;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">upgradeweight</span><span class="params">(avltree &amp;L)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!L) <span class="keyword">return</span>;</span><br><span class="line">    upgradeweight(L-&gt;lchild);</span><br><span class="line">    upgradeweight(L-&gt;rchild);</span><br><span class="line">    L-&gt;weight=get_height(L-&gt;lchild)-get_height(L-&gt;rchild);<span class="comment">//从叶子节点往上计算</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>最小子树根 A 的左旋和右旋四种情况：</p>
<ul>
<li>
<p>LL：由于插入位置在最小子树根<strong>左孩子</strong>的<strong>左子树</strong>上，进行<strong>右旋</strong>。</p>
<ul>
<li>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="assets/image-20221029135655340.png" alt="image-20221029135655340" style="zoom:67%;" />
</li>
<li>
<p>更改下位节点：将<strong>A 的左孩子</strong> 改成 <strong>B的右孩子</strong></p>
</li>
<li>
<p>连接上位节点：将B的右孩子设置成A</p>
</li>
<li>
<p>树的根节点赋值为目前根节点</p>
</li>
</ul>
</li>
<li>
<p>RR：由于插入位置在最小子树根<strong>右孩子</strong>的<strong>右子树</strong>上，进行<strong>左旋</strong>。</p>
<ul>
<li>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="assets/image-20221029135948238.png" alt="image-20221029135948238" style="zoom:67%;" />
</li>
<li>更改下位节点：将<strong>A 的右孩子</strong> 改成 <strong>B的左孩子</strong></li>
<li>连接上位节点：将B的左孩子设置成A</li>
<li>树的根节点赋值为目前根节点</li>
</ul>
</li>
<li>
<p>LR：由于插入位置在最小子树根<strong>左孩子</strong>的<strong>右子树</strong>上，进行<strong>右旋后左旋</strong>。</p>
<ul>
<li>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="assets/image-20221029140252695.png" alt="image-20221029140252695" style="zoom:67%;" />
</li>
<li>
<p>相当于对B进行一次 RR操作（影响BC），然后对A进行一次LL操作</p>
</li>
</ul>
</li>
<li>
<p>RL：由于插入位置在最小子树根<strong>右孩子</strong>的<strong>左子树</strong>上，进行<strong>左旋后右旋</strong>。</p>
<ul>
<li>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="assets/image-20221029140439394.png" alt="image-20221029140439394" style="zoom:67%;" />
</li>
<li>相当于对B进行一次LL操作右旋，再对A进行RR左旋</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">LL</span><span class="params">(avltree &amp;L)</span>&#123;<span class="comment">//左孩子向右旋转</span></span><br><span class="line"><span class="comment">//最小子树根需要更改左孩子，原本的左孩子需要调整右孩子</span></span><br><span class="line">    avltree temp=L-&gt;lchild;<span class="comment">//保存左孩子</span></span><br><span class="line">    L-&gt;lchild=temp-&gt;rchild;<span class="comment">//保存左孩子的右孩子</span></span><br><span class="line">    temp-&gt;rchild=L;<span class="comment">//左孩子的右孩子换成最小字数根</span></span><br><span class="line">    L=temp;<span class="comment">//指向树根</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">RR</span><span class="params">(avltree &amp;L)</span>&#123;</span><br><span class="line">    avltree temp=L-&gt;rchild;</span><br><span class="line">    L-&gt;rchild=temp-&gt;lchild;</span><br><span class="line">    temp-&gt;lchild=L;</span><br><span class="line">    L=temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">LR</span><span class="params">(avltree &amp;L)</span>&#123;<span class="comment">//对左孩子进行右旋，对根节点进行左旋</span></span><br><span class="line">    RR(L-&gt;lchild);</span><br><span class="line">    LL(L);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">RL</span><span class="params">(avltree &amp;L)</span>&#123;</span><br><span class="line">    LL(L-&gt;rchild);<span class="comment">//右旋</span></span><br><span class="line">    RR(L);<span class="comment">//左旋</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>调整平衡算法</p>
<ul>
<li>
<p>对四种失去平衡的情况进行判断，在<strong>L作为最小子树根</strong>的前提下，左右子树绝对值<strong>均等于1</strong>。</p>
</li>
<li>
<p>若函数传参<strong>state=1</strong>：即出现 L平衡因子为2，即左子树比右子树高两个节点，一定是<strong>左子树</strong>新插入了数据</p>
<ul>
<li>如果L的左孩子平衡因子为1，即左孩子的<strong>左子树较高</strong>，<strong>决定了</strong>左孩子的高度的变化，那么肯定插入的数据就在左孩子的左子树中。</li>
<li>反之，则插入在左孩子的右子树中，具体在哪里不重要，进行LR操作。（这也是不太方便将平衡因子的更新和旋转操作联系起来的原因之一）</li>
</ul>
</li>
<li>
<p>反之若函数传参<strong>state=0</strong>：L的平衡因子为-2，情况大致对偶，<strong>右子树</strong>出现问题。</p>
<blockquote>
<p>注意：单纯左右旋之后两个相关节点的平衡因子都是0，不需要重新计算，但是如果是结合的，那么由于不清楚插入的是孩子的孩子的哪一个子树，不太好直接进行赋值，保险起见可以进行<strong>最小子树根部分的平衡因子更新</strong></p>
</blockquote>
</li>
<li>
<p>对于删除函数的复用！</p>
<ul>
<li>删除函数相当于反向插入，我们将不平衡的节点传入函数后，如果删除左边子树的元素，则调用右侧插入的模块，反之亦然</li>
<li>删除函数最大的不同是，左右子树的平衡因子为0，此时不管使用哪种方式都是可以调整的，根据网站，我们使用一次旋转。</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">rebalance</span><span class="params">(avltree &amp;L,<span class="type">int</span> state)</span>&#123;<span class="comment">//对左孩子进行右旋，对根节点进行左旋,state=1,表示左子树问题</span></span><br><span class="line">    avltree temp=(state==<span class="number">1</span>)? L-&gt;lchild:L-&gt;rchild;<span class="comment">//首先确定是左子树还是右子树失衡</span></span><br><span class="line">    <span class="keyword">if</span>(state==<span class="number">1</span>)&#123;<span class="comment">//左子树</span></span><br><span class="line">        <span class="keyword">if</span>(temp-&gt;weight==<span class="number">1</span>||temp-&gt;weight==<span class="number">0</span>)&#123;<span class="comment">//左孩子平衡因子是1，右孩子是-1，右旋后，左孩子的平衡因子是0</span></span><br><span class="line">            LL(L);<span class="comment">//一次右旋操作</span></span><br><span class="line">            upgradeweight(L);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;<span class="comment">//插入在左孩子的右子树</span></span><br><span class="line">            LR(L);<span class="comment">//先右旋再左旋</span></span><br><span class="line">            upgradeweight(L);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;<span class="comment">//temp的上一层因子是 -2  temp是右子树</span></span><br><span class="line">         <span class="keyword">if</span>(temp-&gt;weight==<span class="number">-1</span>||temp-&gt;weight==<span class="number">0</span>)&#123;<span class="comment">//右子 -1，插入到右子树上，进行一次左旋，结束后更新即可</span></span><br><span class="line">            RR(L);</span><br><span class="line">            upgradeweight(L);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;<span class="comment">//反之temp 为 +1 ，插入到了右子树的左子树上先右旋再左旋</span></span><br><span class="line">            RL(L);</span><br><span class="line">            upgradeweight(L);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>节点的<strong>插入</strong>与<strong>初始生成</strong>树</p>
<ul>
<li>
<p><strong>整体</strong>来看插入过程，当插入元素使得父节点或者祖先节点<strong>不平衡</strong>时，需要对最小子树根进行调整，使得<strong>平衡因子为0</strong>，而<strong>在插入元素之前</strong>，最小子树根的<strong>平衡因子为±1</strong>，即插入前高的子树作为根节点高度-1。</p>
</li>
<li>
<p>这意味着插入并调整后<strong>根节点的高度和比插入前相同</strong>，即<strong>不会影响再上一层</strong>的节点平衡。只需要进行一次平衡旋转即可。</p>
</li>
<li>
<p><strong>插入函数</strong>：</p>
<ul>
<li>整体逻辑和二叉搜索树的元素插入相似，递归，当遇到空节点后赋值返回。</li>
<li>当插入完成后，需要寻找最小子树根，这里我们并不采用查找父节点的方法，而是<strong>在递归的过程中完成</strong>
<ul>
<li>在第一次递归插入根节点的<strong>左子树</strong>的时候，预设：<strong>返回时</strong>进行<strong>节点信息的更新</strong>，如果插入后平衡因子出问题，就调用rebalance函数进行<strong>左子树</strong>的调整，同理右子树。</li>
<li>当最后一次插入成功后，返回上一层节点，进行平衡因子的判断，然后<strong>利用递归函数回溯的特性</strong>，将每一次选择子树的节点都进行平衡因子的评估</li>
</ul>
</li>
</ul>
<blockquote>
<p>本函数的实现并不是最优解，按照理论分析是只需要一次调整即可，而我们即使调整后，也会一直回溯到根节点。如果要深究这一点，可以设置一个传递参数flag，来控制一次调整后就不再判断，不过出于简便和直观，在本次试验中就不做更改了。</p>
</blockquote>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="type">void</span> <span class="title function_">insert</span><span class="params">(avltree &amp;L,avltree p)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!L) &#123;L=p;L-&gt;weight=<span class="number">0</span>;L-&gt;height=<span class="number">1</span>;<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;data&lt;L-&gt;data)&#123;<span class="comment">//插入到左子树</span></span><br><span class="line">        insert(L-&gt;lchild,p);</span><br><span class="line">        upgradeweight(L);</span><br><span class="line">        <span class="keyword">if</span>(L-&gt;weight&gt;<span class="number">1</span>)<span class="comment">//左边失衡</span></span><br><span class="line">        rebalance(L,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;<span class="comment">//插入到右子树</span></span><br><span class="line">        insert(L-&gt;rchild,p);</span><br><span class="line">        upgradeweight(L);</span><br><span class="line">        <span class="keyword">if</span>(L-&gt;weight&lt;<span class="number">-1</span>)<span class="comment">//右边失衡</span></span><br><span class="line">        rebalance(L,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span>;<span class="comment">//更新本节点高度  </span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">createavltree</span><span class="params">(avltree &amp;T,<span class="type">float</span> a[])</span>&#123;</span><br><span class="line">    avltree p;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=max;i++) &#123;</span><br><span class="line">        p=new bitnode;</span><br><span class="line">        p-&gt;data=a[i];</span><br><span class="line">        p-&gt;index=since_index;</span><br><span class="line">        p-&gt;lchild=<span class="literal">NULL</span>;</span><br><span class="line">        p-&gt;rchild=<span class="literal">NULL</span>;</span><br><span class="line">        insert(T,p);since_index++;</span><br><span class="line">      <span class="comment">//  print_tree(T); 可以选择每一步都打印下来以供检查</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>节点的插入</p>
<ul>
<li>由于在建立过程中更改了插入函数，这里同之前一样直接调用即可</li>
</ul>
</li>
<li>
<p>节点的搜索</p>
<ul>
<li>
<p>由于旋转，重复的节点不一定存在于右子树，故需要对搜索函数进行修改</p>
</li>
<li>
<p>由于同样的问题，flag设置为1可能也会返回两个结果，所以我们在交互界面进行一次判断输出即可。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span>  <span class="title function_">search_node</span><span class="params">(avltree L,<span class="type">float</span> temp,avltree result[],<span class="type">int</span> &amp;resultnum)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!L) &#123;<span class="keyword">return</span> ;&#125;</span><br><span class="line">    <span class="keyword">if</span>(L-&gt;data==temp) &#123;</span><br><span class="line">        result[resultnum++]=L;</span><br><span class="line">        <span class="keyword">if</span>(flag) <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span>(temp&lt;=L-&gt;data)  search_node(L-&gt;lchild,temp,result,resultnum);</span><br><span class="line">    <span class="keyword">if</span>(temp&gt;=L-&gt;data)  search_node(L-&gt;rchild,temp,result,resultnum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>节点的删除</p>
<ul>
<li>
<p>在插入函数的分析中，我们会不断回溯路径检查，这虽然对于插入过程不必要，但是对于删除函数是非常必要的，我们直接<strong>沿用之前的思路</strong>：<strong>利用递归的回溯进行节点的删除</strong>。（而不是上个实验中使用的搜索定位查找父节点等方法）</p>
</li>
<li>
<p>设置<strong>递归出口</strong>：当我们删除的节点和本节点相同</p>
<ul>
<li><strong>和之前的删除步骤相同</strong>，分成至少有一个空孩子和两个都不是的情况，分别使用找父节点后赋值，和找右子树最左节点的交换后归为前面情况的方法，由于之前详细说明过，这里不再赘述。</li>
<li>不同的是，需要另外设置一个参数root表示<strong>整棵树的根节点</strong>，如果删除的是这个节点的话，需要额外赋值处理！</li>
</ul>
</li>
<li>
<p>将元素的大小和当前根节点的数值比较，<strong>递归删除</strong>左右子树中的目标节点</p>
</li>
<li>
<p>当真的删除完成后返回时，对当前节点的所有<strong>平衡因子进行更新</strong>，如果出现问题，则根据上次递归插入的是右子树还是左子树，进行调用rebalance函数。</p>
</li>
<li>
<p><strong>注意</strong>：和上一个函数完全相同的问题，前驱和后继的位置</p>
<blockquote>
<p>用户交互程序几乎完全相同，不再列出</p>
</blockquote>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span>  <span class="title function_">delete_one_value</span><span class="params">(avltree&amp;root,avltree&amp;L,avltree p,avltree father)</span>&#123;<span class="comment">//前者表示总共树的指针</span></span><br><span class="line">    avltree max_right,q;                                 </span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(p!=L&amp;&amp;p-&gt;data&gt;=L-&gt;data)&#123;</span><br><span class="line">        delete_one_value(root,L-&gt;rchild,p,father);</span><br><span class="line">        upgradeweight(L);</span><br><span class="line">        <span class="keyword">if</span>(L-&gt;rchild&amp;&amp;L-&gt;rchild-&gt;weight&lt;<span class="number">-1</span>)&#123;<span class="comment">//这里对应的情况是找左子树的元素凑过来</span></span><br><span class="line">            rebalance(L-&gt;rchild,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(L-&gt;rchild&amp;&amp;L-&gt;rchild-&gt;weight&gt;<span class="number">1</span>) rebalance(L-&gt;rchild,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(L-&gt;weight&gt;<span class="number">1</span>) rebalance(L,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(p!=L&amp;&amp;p-&gt;data&lt;L-&gt;data)&#123;</span><br><span class="line">        delete_one_value(root,L-&gt;lchild,p,father);</span><br><span class="line">        upgradeweight(L);</span><br><span class="line">        <span class="keyword">if</span>(L-&gt;lchild&amp;&amp;L-&gt;lchild-&gt;weight&lt;<span class="number">-1</span>)&#123;</span><br><span class="line">            rebalance(L-&gt;lchild,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(L-&gt;lchild&amp;&amp;L-&gt;lchild-&gt;weight&gt;<span class="number">1</span>) rebalance(L-&gt;lchild,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(L-&gt;weight&lt;<span class="number">-1</span>) rebalance(L,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(L==p)&#123;<span class="comment">//找到删除的节点</span></span><br><span class="line">    <span class="keyword">if</span> (!p-&gt;lchild&amp;&amp;!p-&gt;rchild)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p==root) &#123;root=<span class="literal">NULL</span>;<span class="keyword">return</span>;&#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(father-&gt;lchild==p)  father-&gt;lchild=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">else</span> father-&gt;rchild=<span class="literal">NULL</span>;</span><br><span class="line">        delete p;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!p-&gt;lchild)&#123;<span class="comment">//无左孩子</span></span><br><span class="line">        <span class="keyword">if</span>(p==root) root=root-&gt;rchild;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(father-&gt;lchild==p)  father-&gt;lchild=p-&gt;rchild;</span><br><span class="line">        <span class="keyword">else</span> father-&gt;rchild=p-&gt;rchild;</span><br><span class="line">        delete p;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!p-&gt;rchild)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p==root) root=root-&gt;lchild;<span class="comment">//如果是根节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(father-&gt;lchild==p)  father-&gt;lchild=p-&gt;lchild;</span><br><span class="line">        <span class="keyword">else</span> father-&gt;rchild=p-&gt;lchild;</span><br><span class="line">        delete p;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">//有左右子树</span></span><br><span class="line">        max_right=p-&gt;lchild;</span><br><span class="line">        q=max_right;</span><br><span class="line">        <span class="keyword">while</span>(max_right-&gt;rchild)&#123;<span class="comment">//找到左子树的最右节点</span></span><br><span class="line">            q=max_right;</span><br><span class="line">            max_right=max_right-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;data=max_right-&gt;data;<span class="comment">//交换节点的值，这里可以自己写个函数</span></span><br><span class="line">        p-&gt;index=max_right-&gt;index;</span><br><span class="line">        <span class="keyword">if</span>(q-&gt;rchild==<span class="literal">NULL</span>)&#123;q=p;&#125;<span class="comment">//否则p不是父节点</span></span><br><span class="line">        delete_one_value(root,L-&gt;lchild,max_right,q);<span class="comment">//换过之后头结点是L-》data=目标则找了右子树（和重复矛盾故单独处理后调整L的平衡）</span></span><br><span class="line">         <span class="keyword">if</span>(L-&gt;lchild&amp;&amp;L-&gt;lchild-&gt;weight&lt;<span class="number">-1</span>)&#123;</span><br><span class="line">            rebalance(L-&gt;lchild,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(L-&gt;lchild&amp;&amp;L-&gt;lchild-&gt;weight&gt;<span class="number">1</span>) rebalance(L-&gt;lchild,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(L-&gt;weight&lt;<span class="number">-1</span>) rebalance(L,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
<h4 id="实验效果："><strong>实验效果</strong>：</h4>
<p>初始化20个50以内的数，菜单页面一致，（后续做了一点修改，大致一样）</p>
<ol>
<li>
<p>建立</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="assets/image-20221029154234337.png" alt="image-20221029154234337" style="zoom:67%;" />
</li>
<li>
<p>删除数据</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="assets/image-20221029154300026.png" alt="image-20221029154300026" style="zoom:67%;" />
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="assets/image-20221029154315756.png" alt="image-20221029154315756" style="zoom:67%;" />
</li>
<li>
<p>添加数据</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="assets/image-20221029154347054.png" alt="image-20221029154347054" style="zoom:67%;" />
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="assets/image-20221029154404615.png" alt="image-20221029154404615" style="zoom:67%;" />
</li>
</ol>
<p><strong>实验感想</strong>：</p>
<ul>
<li>在avl树中，一开始在平衡因子的处理上，有<strong>试图</strong>建立一个taller变量用于表示树是否发生高度的变化，（比如当前节点平衡因子是-1时，只会在插入右子树时发生高度变化），但是十分繁琐，即使在插入部分实现了，到删除部分又需要重新设置。故<strong>放弃</strong>了这种方法，<strong>将平衡因子的计算和调整平衡过程剥离</strong>，直接利用求高度算法进行计算，能够很好的将插入和删除过程的大部分内容整合一致。</li>
<li>在进行avl树的创建时，一定要注意 LR等情况的处理顺序和字面意义不同，是首先处理孩子的问题，即先进行RR操作</li>
</ul>
<h4 id="时间复杂度分析-2"><strong>时间复杂度分析</strong></h4>
<ul>
<li>构造的平均和最差时间复杂度是O(nlogn)</li>
<li>搜索插入和删除均为O(logn）</li>
</ul>
<h3 id="（三）红黑树">（三）红黑树</h3>
<h4 id="实验要求：-3"><strong>实验要求</strong>：</h4>
<p>给定一个n元素的实数数组，构建红黑树，实现节点的插入删除和搜索功能</p>
<h4 id="实验内容：-3"><strong>实验内容</strong>：</h4>
<ol>
<li>
<p>红黑树的要求</p>
<ul>
<li>根为黑色，所有的nil节点为黑色</li>
<li>红色节点的两个字节点为黑色</li>
<li>所有节点到叶子结点的简单路径有相同数目的黑色节点</li>
</ul>
</li>
<li>
<p>数据结构</p>
<p>采用书上的结构，节点有左右孩子和父亲的指针，同时设置color表示颜色，此处红色为1，黑色为0</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">bitnode</span>&#123;</span></span><br><span class="line">    <span class="type">float</span> data;</span><br><span class="line">    <span class="type">int</span> index;</span><br><span class="line">    <span class="type">int</span> color;<span class="comment">//1是红色</span></span><br><span class="line">    bitnode* lchild,*rchild,*parent;</span><br><span class="line">&#125;*rbtree;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>树的插入与建立</p>
<ul>
<li>
<p>左右旋函数</p>
<ul>
<li>
<p>和之前的算法的不同点</p>
<ul>
<li>需要设置<strong>父节点</strong></li>
<li>之前的函数是将传入节点当成一个子树，调整完成之后子树的指针需要指向新的子树的头结点，但是这里我们是将一整个树的根节点作为参数传入，对待更改y节点的子树进行旋转，完成后并<strong>不更改y的具体指向</strong>。</li>
</ul>
</li>
<li>
<p>算法结束后，<strong>y指针指向被拉下来的节点</strong>，也就是调用函数时候的父节点</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">LL</span><span class="params">(rbtree &amp;root,rbtree y)</span>&#123;<span class="comment">//右旋，这里不能对y的值进行改变，不然原来的树会出问题</span></span><br><span class="line">    rbtree x=y-&gt;lchild;</span><br><span class="line">    y-&gt;lchild=x-&gt;rchild;<span class="comment">//下位节点的孩子换一换</span></span><br><span class="line">    <span class="keyword">if</span>(x-&gt;rchild!=<span class="literal">NULL</span>) x-&gt;rchild-&gt;parent=y;<span class="comment">//上面的配套服务</span></span><br><span class="line">    x-&gt;parent=y-&gt;parent;</span><br><span class="line">    <span class="keyword">if</span>(y-&gt;parent==<span class="literal">NULL</span>) root=x;<span class="comment">//树根节点设置为x</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(y==y-&gt;parent-&gt;rchild) y-&gt;parent-&gt;rchild=x;</span><br><span class="line">    <span class="keyword">else</span> y-&gt;parent-&gt;lchild=x;</span><br><span class="line">    x-&gt;rchild=y;<span class="comment">//上位节点再联系孩子，即下位节点</span></span><br><span class="line">    y-&gt;parent=x;<span class="comment">//配套服务</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">RR</span><span class="params">(rbtree &amp;root,rbtree x)</span>&#123;</span><br><span class="line">    rbtree y=x-&gt;rchild;</span><br><span class="line">    x-&gt;rchild=y-&gt;lchild;<span class="comment">//下位</span></span><br><span class="line">    <span class="keyword">if</span>(y-&gt;lchild!=<span class="literal">NULL</span>) y-&gt;lchild-&gt;parent=x;</span><br><span class="line">    y-&gt;parent=x-&gt;parent;</span><br><span class="line">    <span class="keyword">if</span>(x-&gt;parent==<span class="literal">NULL</span>) root=y;</span><br><span class="line">    <span class="keyword">else</span>  <span class="keyword">if</span>(x-&gt;parent-&gt;lchild==x) x-&gt;parent-&gt;lchild=y;</span><br><span class="line">    <span class="keyword">else</span> x-&gt;parent-&gt;rchild=y;</span><br><span class="line">    y-&gt;lchild=x;</span><br><span class="line">    x-&gt;parent=y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>插入函数</p>
<ul>
<li>
<p>参考ppt上的算法，和之前的递归插入不同，这里直接搜索到需要插入的位置（其实之前的插入也可以这样优化，包括一些递归函数，后面再说）</p>
</li>
<li>
<p>插入节点默认设置为红色，这部分在create 函数和userinsert函数中提前设置好</p>
</li>
<li>
<p>然后直接进行整个树的颜色调整</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">insert</span><span class="params">(rbtree &amp;L,rbtree z)</span>&#123;<span class="comment">//L是整个树的根节点，不使用递归</span></span><br><span class="line">    rbtree y=<span class="literal">NULL</span>;<span class="comment">//用于记录双亲</span></span><br><span class="line">    rbtree x=L;<span class="comment">//头结点，明明大于等于放在右子树了，</span></span><br><span class="line">    <span class="keyword">while</span> (x != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        y = x;</span><br><span class="line">        <span class="keyword">if</span> (z-&gt;data &lt; x-&gt;data) x = x-&gt;lchild;</span><br><span class="line">        <span class="keyword">else</span> x = x-&gt;rchild;</span><br><span class="line">    &#125;</span><br><span class="line">    z-&gt;parent=y;<span class="comment">//y是p的双亲，但是不确定是左孩子还是右孩子</span></span><br><span class="line">    <span class="keyword">if</span> (y == <span class="literal">NULL</span>) L = z; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (z-&gt;data &lt; y-&gt;data) y-&gt;lchild = z;        </span><br><span class="line">    <span class="keyword">else</span> y-&gt;rchild = z;</span><br><span class="line">    <span class="comment">//节点的颜色默认为红色  </span></span><br><span class="line">    rbtree_insert_fixup(L, z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>插入节点调整，参考ppt内容</p>
<ul>
<li>
<p>自下而上进行调整，如果插入位置父亲是黑色，<strong>不需要调整</strong>，反之父亲是红色，祖父是黑色</p>
</li>
<li>
<p>观察<strong>叔叔</strong>，如果<strong>叔叔是红色</strong>，那么将父辈俩节点和祖父的颜色对调，然后观察祖父颜色是否需要调整</p>
</li>
<li>
<p>如果<strong>叔叔是黑色</strong></p>
<ul>
<li>我（z）是右孩子，通过一次左旋，可以让我和父亲的位置对调。左旋后<strong>z指向父亲</strong>，也就是<strong>我现在的左孩子</strong>，颜色调整的对象发生改变，在循环中依旧满足z的父亲（就是最初的我）是红色，祖父是黑色，但是此时情况变成了下面这种</li>
<li>我（z）是左孩子，那么需要对祖父进行右旋，让父亲变成祖父的右节点，我变成祖父的左节点即可。此时将祖父设置为黑色，我和父亲为红色</li>
</ul>
</li>
<li>
<p><strong>需要再次强调的是：所有调用的子函数比如LL，z的指向是不能改变的</strong>！</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">rbtree_insert_fixup</span><span class="params">(rbtree &amp;L,rbtree z)</span>&#123;<span class="comment">//为什么这里不用加地址符</span></span><br><span class="line">   rbtree uncle;</span><br><span class="line">   <span class="keyword">while</span>(z-&gt;parent&amp;&amp;z-&gt;parent-&gt;color)&#123;<span class="comment">//父节点是红色，祖父是黑，看叔叔</span></span><br><span class="line">    <span class="comment">//父亲是左孩子,如果是头结点则都</span></span><br><span class="line">    <span class="keyword">if</span>(z-&gt;parent==z-&gt;parent-&gt;parent-&gt;lchild)&#123;</span><br><span class="line">        uncle = z-&gt;parent-&gt;parent-&gt;rchild;</span><br><span class="line">        <span class="comment">//叔叔节点是红色，则把父亲和叔叔节点设置为黑色，祖父为红色，然后调整祖父的颜色</span></span><br><span class="line">            <span class="keyword">if</span> (uncle &amp;&amp; uncle-&gt;color)<span class="comment">//如果等于null则是黑色，故这里需要非空且为红色</span></span><br><span class="line">                &#123;</span><br><span class="line">                    uncle-&gt;color=<span class="number">0</span>;</span><br><span class="line">                    z-&gt;parent-&gt;color=<span class="number">0</span>;</span><br><span class="line">                    z-&gt;parent-&gt;parent-&gt;color=<span class="number">1</span>;</span><br><span class="line">                    z = z-&gt;parent-&gt;parent;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="comment">//叔叔是黑色，且当前节点是右孩子</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(z-&gt;parent-&gt;rchild==z)&#123;</span><br><span class="line">                z=z-&gt;parent;</span><br><span class="line">                RR(L,z);<span class="comment">//让父亲和儿子进行一次左旋        </span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//叔叔是黑色，且当前节点是左孩子</span></span><br><span class="line">            z-&gt;parent-&gt;color=<span class="number">0</span>;</span><br><span class="line">            z-&gt;parent-&gt;parent-&gt;color=<span class="number">1</span>;</span><br><span class="line">            LL(L,z-&gt;parent-&gt;parent);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//父节点是祖父的右孩子</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        uncle = z-&gt;parent-&gt;parent-&gt;lchild;</span><br><span class="line">        <span class="comment">//叔叔节点是红色</span></span><br><span class="line">            <span class="keyword">if</span> (uncle &amp;&amp; uncle-&gt;color)</span><br><span class="line">                &#123;</span><br><span class="line">                    uncle-&gt;color=<span class="number">0</span>;</span><br><span class="line">                    z-&gt;parent-&gt;color=<span class="number">0</span>;</span><br><span class="line">                    z-&gt;parent-&gt;parent-&gt;color=<span class="number">1</span>;</span><br><span class="line">                    z = z-&gt;parent-&gt;parent;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="comment">//叔叔是黑色，且当前节点是右孩子</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(z-&gt;parent-&gt;lchild==z)&#123;</span><br><span class="line">                z=z-&gt;parent;</span><br><span class="line">                LL(L,z);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//叔叔是黑色，且当前节点是左孩子</span></span><br><span class="line">            z-&gt;parent-&gt;color=<span class="number">0</span>;</span><br><span class="line">            z-&gt;parent-&gt;parent-&gt;color=<span class="number">1</span>;</span><br><span class="line">            RR(L,z-&gt;parent-&gt;parent);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   L-&gt;color=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>插入总函数：除了需要默认设置节点的颜色为红色，和我们之前的算法一致，包括交互函数也类似。</p>
</li>
</ul>
</li>
<li>
<p>删除节点</p>
<ul>
<li>
<p>删除函数</p>
<ul>
<li>元素删除：在有空孩子的节点上进行
<ul>
<li>左右孩子均为空，情况可以归入到有一方为空，这里不解释</li>
<li>某个孩子为<strong>空</strong>，比如<strong>左孩子</strong>，此时我们想要把自己的位置<strong>继承给自己右孩子</strong>，头结点单独处理，然后将自己的父亲的孩子设置成自己的右孩子，对应设置<strong>父亲指针</strong>，如果删除的节点是黑色，那么会破坏黑高的问题等，需要对自己的右孩子进行调整。同理另外一种情况。</li>
<li>如果两个孩子都不为空，为了迎合网站，我们换成寻找左孩子的最右节点，然后赋值给替换节点，<strong>情况回归到右孩子为空</strong>。</li>
</ul>
</li>
<li>注意：仍然是前驱节点单独处理的问题</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span>  <span class="title function_">delete_one_value</span><span class="params">(rbtree&amp;L,rbtree p)</span>&#123;<span class="comment">//前者表示总共树的指针</span></span><br><span class="line">    rbtree q=p;<span class="comment">//工具人</span></span><br><span class="line">    rbtree max_right;<span class="comment">//最左节点</span></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;lchild==<span class="literal">NULL</span>)&#123;<span class="comment">//左节点为空，则想办法继承给右孩子！！</span></span><br><span class="line">        <span class="comment">//如果删除的是头结点，则将头结点赋给其右孩子</span></span><br><span class="line">        <span class="keyword">if</span>(!p-&gt;parent)&#123; L=p-&gt;rchild; p-&gt;parent=L;&#125; <span class="comment">//直接赋予即可</span></span><br><span class="line">        <span class="comment">//调整p的孩子和p的父节点的关系</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(p-&gt;parent-&gt;lchild==p)  p-&gt;parent-&gt;lchild=p-&gt;rchild;</span><br><span class="line">        <span class="keyword">else</span> p-&gt;parent-&gt;rchild=p-&gt;rchild;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;rchild)</span><br><span class="line">            p-&gt;rchild-&gt;parent=p-&gt;parent;<span class="comment">//设置好父亲</span></span><br><span class="line">        <span class="keyword">if</span> (!p-&gt;color)<span class="comment">//黑色</span></span><br><span class="line">            rbtree_delete_fixup(L, p-&gt;rchild,p-&gt;parent);</span><br><span class="line">        delete p;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(p-&gt;rchild==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!p-&gt;parent) L=p-&gt;rchild;<span class="comment">//如果是根节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(p-&gt;parent-&gt;lchild==p)  p-&gt;parent-&gt;lchild=p-&gt;lchild;</span><br><span class="line">        <span class="keyword">else</span> p-&gt;parent-&gt;rchild=p-&gt;lchild;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;lchild)</span><br><span class="line">            p-&gt;lchild-&gt;parent=p-&gt;parent;</span><br><span class="line">        <span class="keyword">if</span> (!p-&gt;color)<span class="comment">//黑色</span></span><br><span class="line">            rbtree_delete_fixup(L, p-&gt;lchild,p-&gt;parent);</span><br><span class="line">            <span class="comment">//优化一下不能为空的时候</span></span><br><span class="line">        delete p;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">//有左右子树</span></span><br><span class="line">        max_right=p-&gt;lchild;</span><br><span class="line">        q=max_right;</span><br><span class="line">        <span class="keyword">while</span>(max_right-&gt;rchild)&#123;<span class="comment">//找到左子树的最右节点</span></span><br><span class="line">            q=max_right;</span><br><span class="line">            max_right=max_right-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">//注意！！！q不一定是父亲，如果左子树只有一个元素的话</span></span><br><span class="line">        p-&gt;data=max_right-&gt;data;</span><br><span class="line">        p-&gt;index=max_right-&gt;index;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//最大右节点的父亲的孩子改成最大右节点的左孩子，如果左孩子不为空，则设置父亲</span></span><br><span class="line">        <span class="keyword">if</span>(q-&gt;rchild!=<span class="literal">NULL</span>)&#123;<span class="comment">//一般情况</span></span><br><span class="line">           q-&gt;rchild=max_right-&gt;lchild;</span><br><span class="line">           <span class="keyword">if</span>(max_right-&gt;lchild) max_right-&gt;lchild-&gt;parent=q;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;<span class="comment">//否则左子树最右节点</span></span><br><span class="line">            p-&gt;lchild=max_right-&gt;lchild;</span><br><span class="line">            <span class="keyword">if</span>(max_right-&gt;lchild) max_right-&gt;lchild-&gt;parent=p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//删掉全部的左子树</span></span><br><span class="line">        p=max_right;</span><br><span class="line">        <span class="keyword">if</span> (!p-&gt;color)<span class="comment">//黑色</span></span><br><span class="line">            rbtree_delete_fixup(L, p-&gt;lchild,p-&gt;parent);</span><br><span class="line">        delete max_right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>删除调整函数，按照ppt的伪代码改写</p>
<ul>
<li>如果传入的节点是父亲节点的左孩子
<ul>
<li>Case 1: x的兄弟是红色的</li>
<li>Case 2: x的兄弟是黑色，且兄弟的俩个孩子也都是黑色的</li>
<li>Case 3: x的兄弟是黑色的，并且兄弟的左孩子是红色，右孩子为黑色。</li>
<li>Case 4: x的兄弟是黑色的；并且兄弟的右孩子是红色的，左孩子任意颜色。</li>
</ul>
</li>
<li>反之
<ul>
<li>Case 1: x的兄弟w是红色的</li>
<li>Case 2: x的兄弟w是黑色，且w的俩个孩子也都是黑色的</li>
<li>Case 3: x的兄弟w是黑色的，并且w的左孩子是红色，右孩子为黑色。</li>
<li>// Case 4: x的兄弟w是黑色的；并且w的右孩子是红色的，左孩子任意颜色。</li>
</ul>
</li>
<li>注意，比如要考虑上传节点为空的情况！以及如果没有兄弟节点不需要调整返回即可。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">rbtree_delete_fixup</span><span class="params">(rbtree &amp;root, rbtree &amp;node,rbtree &amp;node_parent)</span>&#123;</span><br><span class="line">    rbtree  other;</span><br><span class="line">    <span class="comment">//调整的是删除元素的继承孩子</span></span><br><span class="line">    <span class="comment">//节点的颜色是黑色需要调整,包括空节点</span></span><br><span class="line">    <span class="keyword">while</span> ((!node ||!node-&gt;color) &amp;&amp; node != root)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (node_parent-&gt;lchild == node)</span><br><span class="line">        &#123;</span><br><span class="line">            other = node_parent-&gt;rchild;</span><br><span class="line">            <span class="keyword">if</span>(!other) <span class="keyword">return</span>;<span class="comment">//兄弟节点没有不需要调整</span></span><br><span class="line">            <span class="keyword">if</span> (other-&gt;color)<span class="comment">//兄弟是红色</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// Case 1: x的兄弟w是红色的  </span></span><br><span class="line">                other-&gt;color=<span class="number">0</span>;</span><br><span class="line">                node_parent-&gt;color=<span class="number">1</span>;</span><br><span class="line">                RR(root, node_parent);</span><br><span class="line">                other = node_parent-&gt;rchild;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!other) <span class="keyword">return</span>;<span class="comment">//兄弟节点没有不需要调整</span></span><br><span class="line">            <span class="keyword">if</span> ((!other-&gt;lchild ||!(other-&gt;lchild-&gt;color)) &amp;&amp;</span><br><span class="line">                (!other-&gt;rchild || !(other-&gt;rchild-&gt;color)))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// Case 2: x的兄弟w是黑色，且w的俩个孩子也都是黑色的  </span></span><br><span class="line">                other-&gt;color=<span class="number">1</span>;</span><br><span class="line">                node = node_parent;</span><br><span class="line">                node_parent = node-&gt;parent;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (!other-&gt;rchild || !(other-&gt;rchild-&gt;color))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// Case 3: x的兄弟w是黑色的，并且w的左孩子是红色，右孩子为黑色。  </span></span><br><span class="line">                    other-&gt;lchild-&gt;color=<span class="number">0</span>;</span><br><span class="line">                    other-&gt;color=<span class="number">1</span>;</span><br><span class="line">                    LL(root, other);</span><br><span class="line">                    other = node_parent-&gt;rchild;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// Case 4: x的兄弟w是黑色的；并且w的右孩子是红色的，左孩子任意颜色。</span></span><br><span class="line">                other-&gt;color=node_parent-&gt;color;</span><br><span class="line">                node_parent-&gt;color=<span class="number">0</span>;</span><br><span class="line">                other-&gt;rchild-&gt;color=<span class="number">0</span>;</span><br><span class="line">                RR(root, node_parent);</span><br><span class="line">                node = root;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            other = node_parent-&gt;lchild;</span><br><span class="line">            <span class="keyword">if</span>(!other) <span class="keyword">return</span>;<span class="comment">//兄弟节点没有不需要调整</span></span><br><span class="line">            <span class="keyword">if</span> (other-&gt;color)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// Case 1: x的兄弟w是红色的  </span></span><br><span class="line">                other-&gt;color=<span class="number">0</span>;</span><br><span class="line">                node_parent-&gt;color=<span class="number">1</span>;</span><br><span class="line">                LL(root, node_parent);</span><br><span class="line">                other = node_parent-&gt;lchild;</span><br><span class="line">         </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!other) <span class="keyword">return</span>;<span class="comment">//兄弟节点没有不需要调整</span></span><br><span class="line">            <span class="keyword">if</span> ((!other-&gt;lchild || !(other-&gt;lchild-&gt;color)) &amp;&amp;</span><br><span class="line">                (!other-&gt;rchild || !(other-&gt;rchild-&gt;color)))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// Case 2: x的兄弟w是黑色，且w的俩个孩子也都是黑色的  </span></span><br><span class="line">                other-&gt;color=<span class="number">1</span>;</span><br><span class="line">                node = node_parent;</span><br><span class="line">                node_parent = node-&gt;parent;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (!other-&gt;lchild || !(other-&gt;lchild-&gt;color))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// Case 3: x的兄弟w是黑色的，并且w的左孩子是红色，右孩子为黑色。  </span></span><br><span class="line">                    other-&gt;rchild-&gt;color=<span class="number">0</span>;</span><br><span class="line">                    other-&gt;color=<span class="number">1</span>;</span><br><span class="line">                    RR(root, other);</span><br><span class="line">                    other = node_parent-&gt;lchild;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// Case 4: x的兄弟w是黑色的；并且w的右孩子是红色的，左孩子任意颜色。</span></span><br><span class="line">                other-&gt;color= node_parent-&gt;color;</span><br><span class="line">                node_parent-&gt;color=<span class="number">0</span>;</span><br><span class="line">                other-&gt;lchild-&gt;color=<span class="number">0</span>;</span><br><span class="line">                LL(root, node_parent);</span><br><span class="line">                node = root;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node) node-&gt;color=<span class="number">0</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>删除总函数类似，不作介绍。</p>
</li>
</ul>
</li>
<li>
<p>搜索和打印功能和平衡树类似，不多介绍</p>
</li>
</ol>
<h4 id="实验结果："><strong>实验结果</strong>：</h4>
<ol>
<li>
<p>红黑树建立</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="assets/image-20221101190811069.png" alt="image-20221101190811069" style="zoom:67%;" />
</li>
<li>
<p>搜索</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="assets/image-20221101190841345.png" alt="image-20221101190841345" style="zoom:67%;" />
</li>
<li>
<p>插入 10</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="assets/image-20221101190910735.png" alt="image-20221101190910735" style="zoom:67%;" />
</li>
<li>
<p>删除 22</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="assets/image-20221101190948508.png" alt="image-20221101190948508" style="zoom:67%;" />
</li>
</ol>
<h3 id="（四）b树">（四）b树</h3>
<h4 id="实验要求"><strong>实验要求</strong></h4>
<p>给定一个n元素的实数数组，构建b树，实现节点的插入删除和搜索功能</p>
<h4 id="实验过程"><strong>实验过程</strong></h4>
<ol>
<li>
<p>order 阶  b树的结构特征</p>
<p>① 每一个节点最多有 order 个子节点child</p>
<p>② 每一个非叶子节点(除根节点)最少有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⌈</mo><mi>o</mi><mi>r</mi><mi>d</mi><mi>e</mi><mi>r</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">⌉</mo></mrow><annotation encoding="application/x-tex">\lceil order/2 \rceil</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌈</span><span class="mord mathnormal" style="margin-right:0.02778em;">or</span><span class="mord mathnormal">d</span><span class="mord mathnormal" style="margin-right:0.02778em;">er</span><span class="mord">/2</span><span class="mclose">⌉</span></span></span></span>个子节点</p>
<p>③根节点若非叶子节点， 那么它至少拥有两个子节点</p>
<p>④有 k 个子节点的非叶子结点拥有k-1个键</p>
<p>⑤叶子节点最少拥有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⌈</mo><mi>o</mi><mi>r</mi><mi>d</mi><mi>e</mi><mi>r</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">⌉</mo><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\lceil order/2 \rceil -1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌈</span><span class="mord mathnormal" style="margin-right:0.02778em;">or</span><span class="mord mathnormal">d</span><span class="mord mathnormal" style="margin-right:0.02778em;">er</span><span class="mord">/2</span><span class="mclose">⌉</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>个键</p>
<p>⑥所有叶子节点属于同一层</p>
<p>作一个更加清晰的划分：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>键</th>
<th>子节点</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>每个节点</td>
<td>最多有order-1个键</td>
<td>最多有order个子节点</td>
<td>需要多设置一个位置用于后续处理</td>
</tr>
<tr>
<td>根节点</td>
<td>如果不是叶子节点至少有一个键</td>
<td>至少有两个子节点</td>
<td>初始化可以根节点为空</td>
</tr>
<tr>
<td>非叶子节点</td>
<td>至少$\lceil order/2 \rceil $-1个键</td>
<td>至少有 $\lceil order/2 \rceil $个子节点</td>
<td></td>
</tr>
<tr>
<td>叶子结点</td>
<td>至少有 $\lceil order/2 \rceil-1 $个键</td>
<td>无子节点</td>
<td></td>
</tr>
</tbody>
</table>
</li>
<li>
<p>链表相关</p>
<ul>
<li>
<p>数据结构：所有的数组下标都从1开始计数，方便观察</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> order 3   <span class="comment">//设置阶数 3阶b树只能存储两个数据</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">bitnode</span></span></span><br><span class="line"><span class="class">&#123;</span>                              <span class="comment">//所有的数据都从1 开始存储</span></span><br><span class="line">    <span class="type">int</span> datanum;               <span class="comment">//节点中数据的个数</span></span><br><span class="line">    <span class="type">float</span> data[order+<span class="number">1</span>];         <span class="comment">//除了a[0]还需要有一个多余的暂时存储待分割部分</span></span><br><span class="line">    <span class="type">int</span> data_index[order+<span class="number">1</span>];     <span class="comment">//用于记录唯一索引（如果输入数据不重复则不需考虑）</span></span><br><span class="line">    bitnode *child[order + <span class="number">2</span>]; <span class="comment">// 容纳的子节点数量永远要比元素多一个</span></span><br><span class="line">    bitnode *parent;           <span class="comment">//父节点</span></span><br><span class="line">&#125; * b_tree;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>链表的初始化和之前一致，更改链表的销毁函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">destroyb_tree</span><span class="params">(b_tree &amp;L)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i ;</span><br><span class="line">    <span class="keyword">if</span> (!L)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i &lt; L-&gt;datanum + <span class="number">1</span>; i++)  &#123;</span><br><span class="line">        <span class="keyword">if</span> (L-&gt;child[i])</span><br><span class="line">            destroyb_tree(L-&gt;child[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    delete L;</span><br><span class="line">    L = <span class="literal">NULL</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>更改打印函数：为了方便观察，将原来的打印函数稍微修改，以打印b树的特征，下面是更改部分，将原本的判断变量<code>isleft</code>更换为<code>notright</code>，每次节点输出所有的数据即可，仍然使用递归调用。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; (notright ? <span class="string">&quot;├──&quot;</span> : <span class="string">&quot;└──&quot;</span>); <span class="comment">//最右侧的元素才输出后一个符号</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= node-&gt;datanum; i++)    <span class="built_in">cout</span> &lt;&lt; node-&gt;data[i] &lt;&lt; <span class="string">&quot;(id: &quot;</span> &lt;&lt;node-&gt;data_index[i]&lt;&lt;<span class="string">&quot;)&quot;</span>;<span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= node-&gt;datanum; i++)&#123;<span class="comment">//下面是所有的非右子树打印 </span></span><br><span class="line">            printBT(pre + (notright ? <span class="string">&quot;│   &quot;</span> : <span class="string">&quot;    &quot;</span>), node-&gt;child[i], <span class="literal">true</span>);</span><br><span class="line">        &#125;<span class="comment">//打印右子树</span></span><br><span class="line">        printBT(pre + (notright ? <span class="string">&quot;│   &quot;</span> : <span class="string">&quot;    &quot;</span>), node-&gt;child[node-&gt;datanum + <span class="number">1</span>], <span class="literal">false</span>); </span><br></pre></td></tr></table></figure>
</li>
<li>
<p>树的建立和节点的插入</p>
<ul>
<li>
<p>辅助函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">isfull</span><span class="params">(b_tree L)</span><span class="comment">//树满返回1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!L) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (L-&gt;datanum &lt; order)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">isleaf</span><span class="params">(b_tree L)</span>&#123;<span class="comment">//叶子节点返回1</span></span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(i;i&lt;=L-&gt;datanum+<span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(L-&gt;child[i]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>节点的插入函数</p>
<ul>
<li>和之前我们直接传入节点类型不同，这次我们直接输入值和索引</li>
<li>如果是<strong>空树</strong>，创建新节点，初始化然后将节点的数据放在第一个位置</li>
<li>如果是<strong>叶子节点</strong>，使用类似于插入排序的方式将节点插入，如果超过order-1，则使用split函数，重复的节点我们依旧放右边</li>
<li><strong>非叶子节点</strong>则找叶子节点，将<strong>小于等于</strong>键的内容插入到左侧，这里是为了迎合网站的喜好，当然如果不插入重复的那就都一样</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">insert</span><span class="params">(b_tree &amp;L, <span class="type">float</span> a, <span class="type">int</span> since_index)</span></span><br><span class="line">&#123; <span class="comment">//需要自己分配空间</span></span><br><span class="line">    b_tree temp = L,check_fa;</span><br><span class="line">    <span class="type">int</span> i , j; <span class="comment">// i指向最后一元素</span></span><br><span class="line">    <span class="keyword">if</span> (!L)<span class="comment">//空树</span></span><br><span class="line">    &#123;</span><br><span class="line">        L = new bitnode;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= order; j++) <span class="comment">//节点的初始化,虽然只能存放order-1的数据，我们</span></span><br><span class="line">        &#123;</span><br><span class="line">            L-&gt;child[j] = <span class="literal">NULL</span>;</span><br><span class="line">            L-&gt;data[j] = <span class="number">0</span>;</span><br><span class="line">            L-&gt;data_index[j]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        L-&gt;child[order+<span class="number">1</span>]=<span class="literal">NULL</span>;</span><br><span class="line">        L-&gt;data[<span class="number">1</span>] = a;<span class="comment">//对数据录入</span></span><br><span class="line">        L-&gt;data_index[<span class="number">1</span>]=since_index;</span><br><span class="line">        L-&gt;datanum = <span class="number">1</span>;</span><br><span class="line">        L-&gt;parent = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isleaf(temp))<span class="comment">//叶子节点</span></span><br><span class="line">    &#123; </span><br><span class="line">        temp-&gt;datanum++;</span><br><span class="line">        i= temp-&gt;datanum - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (a &lt; temp-&gt;data[i] &amp;&amp; i &gt;= <span class="number">0</span>)</span><br><span class="line">        &#123; <span class="comment">//还是默认等于插在右侧，如果要提的话就顶多id不一样</span></span><br><span class="line">            temp-&gt;data[i + <span class="number">1</span>] = temp-&gt;data[i];</span><br><span class="line">            temp-&gt;data_index[i+<span class="number">1</span>]=temp-&gt;data_index[i];</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        temp-&gt;data[i + <span class="number">1</span>] = a; </span><br><span class="line">        temp-&gt;data_index[i+<span class="number">1</span>]=since_index;</span><br><span class="line">        <span class="keyword">if</span>(isfull(temp)) &#123;<span class="comment">//如果节点满了调用split函数向上提交，并观察父节点是否因此变化</span></span><br><span class="line">            check_fa=split_tree(temp);</span><br><span class="line">            <span class="keyword">while</span> (isfull(check_fa))&#123;</span><br><span class="line">                check_fa=split_tree(check_fa);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//不是叶子节点找子树进去,子树为 child[num-1]</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= temp-&gt;datanum ; i++)<span class="comment">//和所有的数据都比一遍</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a &lt;= temp-&gt;data[i]) <span class="comment">//这里为了迎合验算网站的喜好，把相同元素放左边</span></span><br><span class="line">        &#123;</span><br><span class="line">            insert(temp-&gt;child[i], a, since_index);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    insert(temp-&gt;child[temp-&gt;datanum+<span class="number">1</span>], a, since_index); <span class="comment">//大于所有元素的子树</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>节点的分裂函数</p>
<ul>
<li>
<p>当节点的数量达到 order的时候，向上递交</p>
</li>
<li>
<p>因为数组下标从1开始，需要自己额外设置提交节点的下标，如果是奇数则中间元素，如果是偶数则中间偏前的数</p>
</li>
<li>
<p>待分裂的节点所有的指针被分裂后的小节点瓜分</p>
</li>
<li>
<p>父节点为空，则将原来的节点作为树根</p>
</li>
<li>
<p>父节点不为空，如图示，把所有的右侧数据向右移动，空出的位置分别放置提交的元素，和指向新节点的指针。图示仅作思路，并不具体，元素数量也没有考究。</p>
</li>
<li>
<p><strong>注意</strong>：分裂过程不仅发生在子节点，如果提交的元素超过容量，同样需要继续向上提交，此时孩子和父亲的继承关系要妥善处理。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">b_tree <span class="title function_">split_tree</span><span class="params">(b_tree &amp;L)</span></span><br><span class="line">&#123;</span><br><span class="line">    b_tree bp1, bp2,temp;</span><br><span class="line">    <span class="type">int</span> num = L-&gt;datanum, split , i,j; </span><br><span class="line">    split=num/<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">    bp1 = new bitnode;</span><br><span class="line">    bp2 = new bitnode;</span><br><span class="line">    bp1-&gt;datanum = split<span class="number">-1</span>;</span><br><span class="line">    bp2-&gt;datanum = (num - split);</span><br><span class="line">    <span class="comment">//前面小于等于后面</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= order; i++)&#123;<span class="comment">//从1到order=3都初始化，虽然节点要求保持俩</span></span><br><span class="line">        bp1-&gt;child[i] = <span class="literal">NULL</span>;</span><br><span class="line">        bp2-&gt;child[i] = <span class="literal">NULL</span>;     </span><br><span class="line">        bp1-&gt;data[i] = <span class="number">0</span>;</span><br><span class="line">        bp1-&gt;data_index[i] = <span class="number">0</span>;</span><br><span class="line">        bp2-&gt;data[i] = <span class="number">0</span>;</span><br><span class="line">        bp2-&gt;data_index[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    bp1-&gt;child[i]=<span class="literal">NULL</span>;</span><br><span class="line">    bp2-&gt;child[i]=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//将继承的子节点补齐</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; split; i++)&#123; <span class="comment">// split=2位置的数上交</span></span><br><span class="line">        bp1-&gt;child[i] = L-&gt;child[i];</span><br><span class="line">        <span class="keyword">if</span>(L-&gt;child[i])</span><br><span class="line">        L-&gt;child[i]-&gt;parent=bp1;<span class="comment">//！！！！！！！！！！！！罪魁祸首，任何设置child的地方都要设置好father</span></span><br><span class="line">        bp1-&gt;data[i] = L-&gt;data[i];</span><br><span class="line">        bp1-&gt;data_index[i] = L-&gt;data_index[i];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    bp1-&gt;child[split]=L-&gt;child[split];</span><br><span class="line">     <span class="keyword">if</span>(L-&gt;child[split])  L-&gt;child[split]-&gt;parent=bp1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = split + <span class="number">1</span>,j=<span class="number">1</span>; i &lt;= num ; i++,j++)&#123;<span class="comment">//num最多为order 即3</span></span><br><span class="line">        bp2-&gt;child[j] = L-&gt;child[i];</span><br><span class="line">        <span class="keyword">if</span>(L-&gt;child[i]) L-&gt;child[i]-&gt;parent=bp2;</span><br><span class="line">        bp2-&gt;data[j] = L-&gt;data[i];</span><br><span class="line">        bp2-&gt;data_index[j]=L-&gt;data_index[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(L-&gt;child[num+<span class="number">1</span>]) L-&gt;child[num+<span class="number">1</span>]-&gt;parent=bp2;</span><br><span class="line">    bp2-&gt;child[j]=L-&gt;child[num+<span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//这里分裂的两个组，指针都比数据多一个，刚好瓜分</span></span><br><span class="line">    <span class="comment">//如果分裂节点的父节点为空，则保留作为父节点</span></span><br><span class="line">    <span class="keyword">if</span>(!L-&gt;parent)&#123;</span><br><span class="line">        bp1-&gt;parent = L;</span><br><span class="line">        bp2-&gt;parent = L;</span><br><span class="line">        L-&gt;datanum = <span class="number">1</span>;</span><br><span class="line">        L-&gt;child[<span class="number">1</span>] = bp1;</span><br><span class="line">        L-&gt;child[<span class="number">2</span>] = bp2;</span><br><span class="line"></span><br><span class="line">        L-&gt;data[<span class="number">1</span>] = L-&gt;data[split];</span><br><span class="line">        L-&gt;data_index[<span class="number">1</span>]=L-&gt;data_index[split];</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">3</span>; i &lt;= num; i++)&#123;</span><br><span class="line">            L-&gt;child[i] = <span class="literal">NULL</span>;</span><br><span class="line">            L-&gt;data[i] = <span class="number">0</span>;</span><br><span class="line">            L-&gt;data_index[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;child[num+<span class="number">1</span>]=<span class="literal">NULL</span>;<span class="comment">//指针多一个</span></span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">//父节点不为空，提交的元素位置在父子连接处</span></span><br><span class="line">        <span class="type">int</span> position=<span class="number">1</span>,i=L-&gt;parent-&gt;datanum;</span><br><span class="line">        <span class="keyword">while</span>(L-&gt;parent-&gt;child[position]!=L)position++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(i;i&gt;=position;i--)&#123;</span><br><span class="line">            L-&gt;parent-&gt;data[i+<span class="number">1</span>]=L-&gt;parent-&gt;data[i];</span><br><span class="line">            L-&gt;parent-&gt;data_index[i+<span class="number">1</span>]=L-&gt;parent-&gt;data_index[i];</span><br><span class="line">            L-&gt;parent-&gt;child[i+<span class="number">2</span>]=L-&gt;parent-&gt;child[i+<span class="number">1</span>];</span><br><span class="line">        &#125;<span class="comment">//最后i=position-1</span></span><br><span class="line"></span><br><span class="line">        L-&gt;parent-&gt;data[position]=L-&gt;data[split];</span><br><span class="line">        L-&gt;parent-&gt;data_index[position]=L-&gt;data_index[split];</span><br><span class="line"></span><br><span class="line">        L-&gt;parent-&gt;child[position]=bp1;</span><br><span class="line">        L-&gt;parent-&gt;child[position+<span class="number">1</span>]=bp2;</span><br><span class="line">        </span><br><span class="line">        bp1-&gt;parent = L-&gt;parent;</span><br><span class="line">        bp2-&gt;parent = L-&gt;parent;</span><br><span class="line"></span><br><span class="line">        L-&gt;parent-&gt;datanum++;</span><br><span class="line">        b_tree del_temp=L-&gt;parent;</span><br><span class="line">        delete L;</span><br><span class="line">        <span class="keyword">return</span> del_temp;<span class="comment">//返回向上提交的节点，即可能出问题的节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>交互函数类似，插入函数类似，不作解释</p>
</li>
</ul>
</li>
<li>
<p>数据的删除：数据的插入比较复杂，需要考虑多种情况</p>
<ul>
<li>
<p>思路：将非叶子节点转化为叶子节点，这里使用右子树的最左节点或者左子树的最右节点都行，但是出于和网站的契合度思考，我们采用前者，然后我们直接删除叶子节点的值，并判断叶子结点数目是否过少，是则调用borrow和父节点或者兄弟节点借用，具体借用的方式我们之后再说。</p>
</li>
<li>
<p>首先是一些比较简单的辅助函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">find</span><span class="params">(b_tree p,<span class="type">int</span> id)</span>&#123;<span class="comment">//如果不允许加重复值，可以用value,返回删除的元素在节点中是第几个</span></span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line">    <span class="keyword">for</span>(result=<span class="number">1</span>;result&lt;=p-&gt;datanum;result++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;data_index[result]==id) <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;wrong&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">find_me</span><span class="params">(b_tree p)</span>&#123;<span class="comment">//找到p是自己父亲的第几个孩子</span></span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line">    b_tree q;</span><br><span class="line">    q=p-&gt;parent;</span><br><span class="line">    <span class="keyword">if</span>(!q) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//根节点没有</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q-&gt;datanum+<span class="number">1</span>;i++)&#123;<span class="comment">//时刻注意子树和节点数的关系</span></span><br><span class="line">        <span class="keyword">if</span>(q-&gt;child[i]==p) <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;no child is me&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">isrich</span><span class="params">(b_tree p)</span>&#123;<span class="comment">//判断是否有多的节点可以借过来</span></span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    <span class="keyword">if</span>(!order%<span class="number">2</span>) j=order/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span> j=order/<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(!p-&gt;parent) &#123;<span class="comment">//根节点</span></span><br><span class="line">        <span class="keyword">if</span>(!isleaf(p)) <span class="keyword">return</span> (p-&gt;datanum&gt;=<span class="number">1</span>+<span class="number">1</span>);<span class="comment">//根节点不是叶子节点至少有一个元素</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(isleaf(p)) <span class="keyword">return</span> (p-&gt;datanum&gt;=j<span class="number">-1</span>+<span class="number">1</span>);<span class="comment">//叶子节点至少有j-1个元素</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span>  (p-&gt;datanum&gt;=j+<span class="number">1</span>);<span class="comment">//非叶子节点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">not_lower</span><span class="params">(b_tree p)</span>&#123;<span class="comment">//是否需要调整</span></span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    <span class="keyword">if</span>(!order%<span class="number">2</span>) j=order/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span> j=order/<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(!p-&gt;parent) &#123;<span class="comment">//p是根节点</span></span><br><span class="line">        <span class="keyword">if</span>(!isleaf(p)) <span class="keyword">return</span> (p-&gt;datanum&gt;=<span class="number">1</span>);<span class="comment">//根节点不是叶子节点至少有一个元素</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(isleaf(p)) <span class="keyword">return</span> (p-&gt;datanum&gt;=j<span class="number">-1</span>);<span class="comment">//叶子节点至少有j-1个元素</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span>  (p-&gt;datanum&gt;=j);<span class="comment">//非叶子节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>然后是我们思路实现的插入函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">delete_one_value</span><span class="params">(b_tree &amp;L, b_tree p,<span class="type">int</span> id)</span><span class="comment">//如果唯一的话这里可以把id换成value重写find函数即可</span></span><br><span class="line">&#123;</span><br><span class="line">    b_tree q,max_left;</span><br><span class="line">    <span class="type">int</span> num,i=find(p,id),count;</span><br><span class="line">    <span class="keyword">if</span>(!isleaf(p))&#123;</span><br><span class="line">       max_left=p-&gt;child[i];<span class="comment">//改成了左子树最右节点</span></span><br><span class="line">        <span class="keyword">while</span>(max_left-&gt;child[max_left-&gt;datanum+<span class="number">1</span>])&#123;<span class="comment">//找到右子树的最左节点</span></span><br><span class="line">            q=max_left;</span><br><span class="line">            max_left=max_left-&gt;child[max_left-&gt;datanum+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;data[i]=max_left-&gt;data[max_left-&gt;datanum];</span><br><span class="line">        p-&gt;data_index[i]=max_left-&gt;data_index[max_left-&gt;datanum];</span><br><span class="line"></span><br><span class="line">        p=max_left;</span><br><span class="line">        i=max_left-&gt;datanum;<span class="comment">//需要删除最右边的数据</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//叶子节点直接删除，此时所有的子节点应该都是null不需要考虑</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(count=i;count&lt;=p-&gt;datanum;count++)&#123;</span><br><span class="line">            p-&gt;data[count]=p-&gt;data[count+<span class="number">1</span>];<span class="comment">//最后一个应该是0</span></span><br><span class="line">            p-&gt;data_index[count]=p-&gt;data_index[count+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;datanum--;      </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(!p-&gt;parent) <span class="keyword">return</span>;<span class="comment">//如果是头结点直接删除后不需要考虑元素过少的问题</span></span><br><span class="line">        <span class="type">int</span> index=find_me(p);<span class="comment">//自己是第几个孩子</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!not_lower(p))<span class="comment">//叶子节点要求</span></span><br><span class="line">            borrow_node(L,p,index);<span class="comment">//删除完成后，本节点不符合规矩</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>borrow函数：最复杂的函数，我们分段解释</p>
<ul>
<li>
<p>递归使用，分为几种情况<br>
1.兄弟节点富有，借用父亲节点的值，用兄弟节点补上，不会出现父节点的问题<br>
2.兄弟节点不富有但是父亲节点富有，借用父节点，然后将自己和兄弟节点合并<br>
3.父节点不富有，可能再次调用本函数</p>
</li>
<li>
<p>最特殊的情况：根节点不符合。这只能说明根节点一个元素都没有，如果没有子树，那直接全删，否则发生的情况是：根节点原本只有一个元素，某个孩子借走之后由于兄弟不富有，直接合并并删除了根节点的元素和指针，则此时根节点只有一个孩子，我们只需要把树根赋予这个孩子即可。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(!p-&gt;parent)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!p-&gt;child[<span class="number">1</span>]) &#123;delete p;<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;the tree is totally deleted!! &quot;</span>&lt;&lt;<span class="built_in">endl</span>;<span class="keyword">return</span>;&#125;</span><br><span class="line">        L=p-&gt;child[<span class="number">1</span>];</span><br><span class="line">        delete p;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>接下来需要说明的是，由于每个节点至少有俩孩子，所以p一定有兄弟节点的，问题在于当两边兄弟都富有的时候，找谁借，我们这里默认是找右兄弟借，也就是调用下标为i的父亲元素，如果找左兄弟借，就是调用下标为i-1的元素，但是，<strong>父亲指向本删除节点的指针一定下标为 i ！</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//p是第i个孩子</span></span><br><span class="line">   <span class="keyword">if</span>(i+<span class="number">1</span>&lt;=p-&gt;parent-&gt;datanum+<span class="number">1</span>) right_bro=p-&gt;parent-&gt;child[i+<span class="number">1</span>];</span><br><span class="line">   <span class="keyword">else</span> right_bro=<span class="literal">NULL</span>;</span><br><span class="line">   <span class="keyword">if</span>(i<span class="number">-1</span>&gt;=<span class="number">1</span>) left_bro=p-&gt;parent-&gt;child[i<span class="number">-1</span>];</span><br><span class="line">   <span class="keyword">else</span> left_bro=<span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>如果我们判断<strong>兄弟节点是富有</strong>的</p>
<ul>
<li>父节点不需要调整，相当于递归直接结束</li>
<li>子树的继承问题，我们可以判断触发这个函数的情况只有两种
<ul>
<li>叶子节点的删除，无子树</li>
<li>在向上调整时，<strong>本节点作为父节点</strong>的时候向下借用了孩子并且没有归还（删除了一个指针一个键，故仍完整）。<strong>关键</strong>：假设右兄弟的一个数被放在了父亲节点，其子树是应该放在父亲节点的左子树，而父亲节点此时在本节点的最右边，所以<strong>调整节点的最左是右兄弟的最左指针</strong></li>
</ul>
</li>
<li>过程很明显，首先看右兄弟是否可以借用，如果可以，获取父亲节点放在本节点最右侧，然后把右兄弟最左元素放到父亲节点里，其子树放在本节点的最右侧，右兄弟删除掉最左元素，配置好对应项即可。同理左兄弟。</li>
</ul>
</li>
<li>
<p>如果兄弟节点不富有，那么需要完成节点的合并</p>
<ul>
<li>拉取父节点的元素</li>
<li>将我们自己和兄弟节点合并，如果我们拉取的是i元素，保留的是i+1指针，则和右兄弟合并，如果是i-1，保留的是i指针，和左兄弟合并，注意我们自己可能并不是只有一个父节点借来的元素，可能有很多，所以合并过程需要根据剩余元素判断</li>
<li>我们优先和左兄弟合并</li>
</ul>
</li>
<li>
<p>递归</p>
<ul>
<li>出现递归，说明我们对父亲节点只借不还的现象影响了父节点，此时我们只需要进行一次判断，然后获取父节点是我们祖父节点的第几个孩子，再递归就可以了</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">borrow_node</span><span class="params">(b_tree &amp;L,b_tree &amp;p,<span class="type">int</span> i)</span>&#123;<span class="comment">//p是第i个孩子</span></span><br><span class="line">    b_tree temp,left_bro,right_bro,brother;;</span><br><span class="line">    <span class="type">float</span> meda;</span><br><span class="line">    <span class="type">int</span> count, p_i;;</span><br><span class="line">     <span class="keyword">if</span>(!p-&gt;parent)&#123;</span><br><span class="line">        <span class="keyword">if</span>(isleaf(p)) &#123;delete p;<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;the tree is totally deleted!! &quot;</span>&lt;&lt;<span class="built_in">endl</span>;<span class="keyword">return</span>;&#125;</span><br><span class="line">        L=p-&gt;child[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(L)<span class="comment">//!!!这里很重要</span></span><br><span class="line">        L-&gt;parent=<span class="literal">NULL</span>;</span><br><span class="line">        delete p;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//由于每个节点至少有俩孩子，所以p一定有兄弟节点的,问题在于有几个，当两边兄弟都富有的时候，找谁借，我们这里默认是找右兄弟借</span></span><br><span class="line">    <span class="keyword">if</span>(i+<span class="number">1</span>&lt;=p-&gt;parent-&gt;datanum+<span class="number">1</span>) right_bro=p-&gt;parent-&gt;child[i+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">else</span> right_bro=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(i<span class="number">-1</span>&gt;=<span class="number">1</span>) left_bro=p-&gt;parent-&gt;child[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">else</span> left_bro=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//p是根节点，后面只会让p为空的时候触发，这意味着p作为父节点的时候只有一个节点还被孩子用了</span></span><br><span class="line">    <span class="comment">//则此时孩子会合并成一个孩子，我们只需要把根节点赋值给这个孩子即可</span></span><br><span class="line">    <span class="comment">//还有一种可能，如果根节点已经一无所有，这时候相当于删除了整个树</span></span><br><span class="line">    <span class="keyword">if</span>(left_bro&amp;&amp;isrich(left_bro))&#123;</span><br><span class="line">           <span class="keyword">for</span>(count=p-&gt;datanum;count&gt;=<span class="number">1</span>;count--)&#123;</span><br><span class="line">                p-&gt;child[count+<span class="number">2</span>]=p-&gt;child[count+<span class="number">1</span>];</span><br><span class="line">                p-&gt;data[count+<span class="number">1</span>]=p-&gt;data[count];</span><br><span class="line">                p-&gt;data_index[count+<span class="number">1</span>]=p-&gt;data_index[count];</span><br><span class="line">        &#125;</span><br><span class="line">            p-&gt;child[<span class="number">2</span>]=p-&gt;child[<span class="number">1</span>];<span class="comment">//指针多移动一个</span></span><br><span class="line">            p-&gt;data[<span class="number">1</span>]=p-&gt;parent-&gt;data[i<span class="number">-1</span>];</span><br><span class="line">            p-&gt;data_index[<span class="number">1</span>]=p-&gt;parent-&gt;data_index[i<span class="number">-1</span>];</span><br><span class="line">            p-&gt;child[<span class="number">1</span>]=left_bro-&gt;child[left_bro-&gt;datanum+<span class="number">1</span>];<span class="comment">//继承的是左孩子的最右边子树</span></span><br><span class="line">            <span class="keyword">if</span>(left_bro-&gt;child[left_bro-&gt;datanum+<span class="number">1</span>]) left_bro-&gt;child[left_bro-&gt;datanum+<span class="number">1</span>]-&gt;parent=p;</span><br><span class="line">            p-&gt;datanum++;</span><br><span class="line"></span><br><span class="line">        p-&gt;parent-&gt;data[i<span class="number">-1</span>]=left_bro-&gt;data[left_bro-&gt;datanum];</span><br><span class="line">        p-&gt;parent-&gt;data_index[i<span class="number">-1</span>]=left_bro-&gt;data_index[left_bro-&gt;datanum];</span><br><span class="line">        <span class="comment">//删除左兄弟左节点最右元素，删除都是成对删的！！！</span></span><br><span class="line">        left_bro-&gt;data[left_bro-&gt;datanum]=<span class="number">0</span>;</span><br><span class="line">        left_bro-&gt;data_index[left_bro-&gt;datanum]=<span class="number">0</span>;</span><br><span class="line">        left_bro-&gt;child[left_bro-&gt;datanum+<span class="number">1</span>]=<span class="literal">NULL</span>;</span><br><span class="line">        left_bro-&gt;datanum--;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//确认右节点是否可以借用</span></span><br><span class="line">    <span class="keyword">if</span>(right_bro&amp;&amp;isrich(right_bro))&#123;</span><br><span class="line">             p-&gt;data[p-&gt;datanum+<span class="number">1</span>]=p-&gt;parent-&gt;data[i];</span><br><span class="line">            p-&gt;data_index[p-&gt;datanum+<span class="number">1</span>]=p-&gt;parent-&gt;data_index[i];</span><br><span class="line">            p-&gt;child[p-&gt;datanum+<span class="number">2</span>]=right_bro-&gt;child[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(right_bro-&gt;child[<span class="number">1</span>]) right_bro-&gt;child[<span class="number">1</span>]-&gt;parent=p;</span><br><span class="line">            p-&gt;datanum++;</span><br><span class="line">        <span class="comment">// 右兄弟节点最左边放在父亲被拉下来的位置</span></span><br><span class="line">            p-&gt;parent-&gt;data[i]=right_bro-&gt;data[<span class="number">1</span>];</span><br><span class="line">            p-&gt;parent-&gt;data_index[i]=right_bro-&gt;data_index[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(count=<span class="number">1</span>;count&lt;=right_bro-&gt;datanum;count++)&#123;</span><br><span class="line">            right_bro-&gt;data[count]=right_bro-&gt;data[count+<span class="number">1</span>];</span><br><span class="line">            right_bro-&gt;data_index[count]=right_bro-&gt;data_index[count+<span class="number">1</span>];</span><br><span class="line">            right_bro-&gt;child[count]=right_bro-&gt;child[count+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        right_bro-&gt;child[right_bro-&gt;datanum]=right_bro-&gt;child[right_bro-&gt;datanum+<span class="number">1</span>];</span><br><span class="line">        right_bro-&gt;child[right_bro-&gt;datanum+<span class="number">1</span>]=<span class="literal">NULL</span>;</span><br><span class="line">        right_bro-&gt;data[right_bro-&gt;datanum]=<span class="number">0</span>;</span><br><span class="line">        right_bro-&gt;datanum--;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//检查左兄弟，过程和之前类似</span></span><br><span class="line">    <span class="keyword">if</span>(left_bro)&#123;</span><br><span class="line">         <span class="keyword">for</span>(count=p-&gt;datanum;count&gt;=<span class="number">1</span>;count--)&#123;</span><br><span class="line">                p-&gt;child[count+<span class="number">2</span>]=p-&gt;child[count+<span class="number">1</span>];</span><br><span class="line">                p-&gt;data[count+<span class="number">1</span>]=p-&gt;data[count];</span><br><span class="line">                p-&gt;data_index[count+<span class="number">1</span>]=p-&gt;data_index[count];</span><br><span class="line">        &#125;</span><br><span class="line">            p-&gt;child[<span class="number">2</span>]=p-&gt;child[<span class="number">1</span>];<span class="comment">//指针多移动一个</span></span><br><span class="line">            p-&gt;data[<span class="number">1</span>]=p-&gt;parent-&gt;data[i<span class="number">-1</span>];</span><br><span class="line">            p-&gt;data_index[<span class="number">1</span>]=p-&gt;parent-&gt;data_index[i<span class="number">-1</span>];</span><br><span class="line">            p-&gt;child[<span class="number">1</span>]=left_bro-&gt;child[left_bro-&gt;datanum+<span class="number">1</span>];<span class="comment">//继承的是左孩子的最右边子树</span></span><br><span class="line">            <span class="keyword">if</span>(left_bro-&gt;child[left_bro-&gt;datanum+<span class="number">1</span>]) left_bro-&gt;child[left_bro-&gt;datanum+<span class="number">1</span>]-&gt;parent=p;</span><br><span class="line">            p-&gt;datanum++; </span><br><span class="line">       </span><br><span class="line">         <span class="keyword">for</span>(count=left_bro-&gt;datanum+<span class="number">1</span>,p_i=<span class="number">1</span>;count&lt;=(left_bro-&gt;datanum)+(p-&gt;datanum);count++,p_i++)&#123;<span class="comment">//多移动一个</span></span><br><span class="line">            left_bro-&gt;data[count]=p-&gt;data[p_i];</span><br><span class="line">            left_bro-&gt;data_index[count]=p-&gt;data_index[p_i];</span><br><span class="line">            left_bro-&gt;child[count+<span class="number">1</span>]=p-&gt;child[p_i+<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;child[p_i+<span class="number">1</span>])</span><br><span class="line">               p-&gt;child[p_i+<span class="number">1</span>]-&gt;parent=left_bro;   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;child[<span class="number">1</span>]) p-&gt;child[<span class="number">1</span>]-&gt;parent=left_bro;<span class="comment">//第一个虽然不用移动，但是要重新设置父亲</span></span><br><span class="line">         left_bro-&gt;datanum+=p-&gt;datanum;</span><br><span class="line">        <span class="comment">//开始删除父亲中的元素i-1和指针i</span></span><br><span class="line">        <span class="keyword">for</span>(count=i<span class="number">-1</span>;count&lt;=p-&gt;parent-&gt;datanum;count++)&#123;</span><br><span class="line">            p-&gt;parent-&gt;data[count]=p-&gt;parent-&gt;data[count+<span class="number">1</span>];</span><br><span class="line">            p-&gt;parent-&gt;data_index[count]=p-&gt;parent-&gt;data_index[count+<span class="number">1</span>];</span><br><span class="line">            p-&gt;parent-&gt;child[count+<span class="number">1</span>]=p-&gt;parent-&gt;child[count+<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;parent-&gt;datanum--;</span><br><span class="line">        <span class="comment">//delete p;woc为啥p会在哪里变成brother 啊</span></span><br><span class="line">        <span class="keyword">if</span>(not_lower(left_bro-&gt;parent)) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">        p=left_bro-&gt;parent;</span><br><span class="line">        <span class="comment">//父亲是父亲的父亲的第几个孩子!!!!可能出问题</span></span><br><span class="line">        i=find_me(p);</span><br><span class="line">        borrow_node(L,p,i);<span class="comment">//设置好结束</span></span><br><span class="line">        &#125;</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(right_bro)&#123;<span class="comment">//右兄弟存在</span></span><br><span class="line">        </span><br><span class="line">        p-&gt;data[p-&gt;datanum+<span class="number">1</span>]=p-&gt;parent-&gt;data[i];</span><br><span class="line">            p-&gt;data_index[p-&gt;datanum+<span class="number">1</span>]=p-&gt;parent-&gt;data_index[i];</span><br><span class="line">            p-&gt;child[p-&gt;datanum+<span class="number">2</span>]=right_bro-&gt;child[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(right_bro-&gt;child[<span class="number">1</span>]) right_bro-&gt;child[<span class="number">1</span>]-&gt;parent=p;</span><br><span class="line">            p-&gt;datanum++;</span><br><span class="line">         <span class="type">int</span> dis=<span class="number">1</span>;<span class="comment">//我们把右节点并入自己</span></span><br><span class="line">        <span class="keyword">for</span>(count=p-&gt;datanum+<span class="number">1</span>,dis;dis&lt;=right_bro-&gt;datanum;dis++,count++)&#123;</span><br><span class="line">            p-&gt;data[count]=right_bro-&gt;data[dis];</span><br><span class="line">            p-&gt;data_index[count]=right_bro-&gt;data_index[dis];</span><br><span class="line">            p-&gt;child[count+<span class="number">1</span>]=right_bro-&gt;child[dis+<span class="number">1</span>];<span class="comment">//435改动dis+1</span></span><br><span class="line">            <span class="keyword">if</span>(right_bro-&gt;child[dis+<span class="number">1</span>]) right_bro-&gt;child[dis+<span class="number">1</span>]-&gt;parent=p;</span><br><span class="line">        &#125;</span><br><span class="line">      p-&gt;datanum+=right_bro-&gt;datanum;</span><br><span class="line">    <span class="comment">//将父节点的指针进行删除，即i+1和元素i</span></span><br><span class="line">        <span class="keyword">for</span>(count=i;count&lt;=p-&gt;parent-&gt;datanum;count++)&#123;</span><br><span class="line">            p-&gt;parent-&gt;data[count]=p-&gt;parent-&gt;data[count+<span class="number">1</span>];</span><br><span class="line">            p-&gt;parent-&gt;data_index[count]=p-&gt;parent-&gt;data_index[count+<span class="number">1</span>];</span><br><span class="line">            p-&gt;parent-&gt;child[count+<span class="number">1</span>]=p-&gt;parent-&gt;child[count+<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;parent-&gt;datanum--;</span><br><span class="line">    <span class="comment">//考虑特殊情况，父节点是根节点且被删空，继续调用本函数，返回到这里直接return不会继续回溯</span></span><br><span class="line">        <span class="keyword">if</span>(not_lower(right_bro-&gt;parent)) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">        p=right_bro-&gt;parent;</span><br><span class="line">        <span class="comment">//父亲是父亲的父亲的第几个孩子!!!!可能出问题</span></span><br><span class="line">        i=find_me(p);</span><br><span class="line">        borrow_node(L,p,i);</span><br><span class="line">        &#125;  </span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//父节点不需要调整,直接结束即可</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>数据的搜索：简单修改搜索函数</p>
<ul>
<li>现在搜索会返回唯一的id值，也就是生成数组的下标，如果结合b树的功能，即文件的位置检索的话，可能更偏向于返回指针节点，和该节点对应元素的相对位置，只需要对返回函数进行修改返回i即可，此处并不介绍。</li>
<li>同样是由于一些借用合并操作，不能保证小于等于的只在一边，故flag也只是进行一个初次判断，我们在交互页面修改即可。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">search_node</span><span class="params">(b_tree L, <span class="type">float</span> temp, b_tree result[],<span class="type">int</span> id[], <span class="type">int</span> &amp;resultnum)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">if</span> (!L) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=L-&gt;datanum;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (L-&gt;data[i] == temp) &#123;</span><br><span class="line">            result[resultnum] = L;id[resultnum++]=L-&gt;data_index[i];</span><br><span class="line">            <span class="keyword">if</span>(flag) <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= L-&gt;datanum ; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (temp &lt;= L-&gt;data[i])&#123; </span><br><span class="line">            search_node(L-&gt;child[i], temp, result,id,resultnum);</span><br><span class="line">        &#125;</span><br><span class="line">        search_node(L-&gt;child[L-&gt;datanum+<span class="number">1</span>],temp,result,id,resultnum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="实验结果"><strong>实验结果</strong></h4>
<ol>
<li>
<p>树的建立</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="assets/image-20221103032108165.png" alt="image-20221103032108165" style="zoom:67%;" />
</li>
<li>
<p>搜索</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="assets/image-20221103032135010.png" alt="image-20221103032135010" style="zoom:67%;" />
</li>
<li>
<p>插入 27</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="assets/image-20221103032209011.png" alt="image-20221103032209011" style="zoom:67%;" />
</li>
<li>
<p>删除32</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="assets/image-20221103035312122.png" alt="image-20221103035312122" style="zoom:67%;" />
</li>
</ol>
<h4 id="实验感想："><strong>实验感想</strong>：</h4>
<p>实现过程过于繁琐，由于初次写这种树，想到的就是按照类别依次实现，但是其实可以合并一些步骤，尤其是borrow函数。</p>
<h4 id="时间复杂度分析-3"><strong>时间复杂度分析</strong></h4>
<p>按照ppt中内容：阶数M的搜索插入和删除时间复杂度均为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mi>M</mi></msub><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(log_MN)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></p>
<h3 id="（五）b-树">（五）b+树</h3>
<h4 id="实验要求-2"><strong>实验要求</strong></h4>
<p>给定一个n元素的实数数组，构建b树，实现节点的插入删除和搜索功能</p>
<h4 id="实验过程-2"><strong>实验过程</strong></h4>
<ol>
<li>
<p>树的定义</p>
<p>为了和网站上b+树的定义保持一致，将节点设置为键值比子树少一，并且设置索引为右子树最左节点。（ppt上定义的是左子树最右节点，且每个子树都有索引）</p>
<p>但是这种设计使得叶子节点和其他节点的操作<strong>失去了统一性</strong>，在非叶子节点处可以完全使用b树的操作，而叶子节点需要额外进行设置，为了减少代码冗余，我们在原来的函数基础上修改。（如果使用键值和子树数目相同的定义，则过程将要简单很多）</p>
</li>
</ol>
<table>
<thead>
<tr>
<th>类型</th>
<th>键</th>
<th>子节点</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>每个节点</td>
<td>最多有order-1个键</td>
<td>最多有order个子节点</td>
<td>需要多设置一个位置用于后续处理</td>
</tr>
<tr>
<td>根节点</td>
<td>如果不是叶子节点至少有一个键</td>
<td>至少有两个子节点</td>
<td>初始化可以根节点为空</td>
</tr>
<tr>
<td>非叶子节点</td>
<td>至少$\lceil order/2 \rceil-1 $个键</td>
<td>至少有$\lceil order/2 \rceil $ 个子节点</td>
<td>5阶对应至少俩数</td>
</tr>
<tr>
<td>叶子结点</td>
<td>至少有$\lceil order/2 \rceil-1 $个键</td>
<td>无子节点</td>
<td>设置next指针</td>
</tr>
</tbody>
</table>
<ol start="2">
<li>
<p>树的建立</p>
<ul>
<li>
<p>数据结构</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">bitnode</span></span></span><br><span class="line"><span class="class">&#123;</span>                              </span><br><span class="line">    <span class="type">int</span> datanum;               <span class="comment">//节点中数据的个数</span></span><br><span class="line">    <span class="type">float</span> data[order+<span class="number">2</span>];         <span class="comment">//所有的数据从1开始计数，最多order个数据，这里多设置一个是因为以后如果改成另外一种定义也可</span></span><br><span class="line">    <span class="type">int</span> data_index[order+<span class="number">2</span>];</span><br><span class="line">    bitnode *child[order + <span class="number">2</span>]; <span class="comment">// child[num+1],最大也比data大一个</span></span><br><span class="line">    bitnode *parent;           <span class="comment">//父节点</span></span><br><span class="line">    bitnode * next;</span><br><span class="line">    bitnode * pre;</span><br><span class="line">&#125; * bptree;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>定义<strong>辅助</strong>函数：在b树都有说明，一致</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">isfull</span><span class="params">(bptree L)</span>;<span class="comment">//判断是否需要分裂</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isleaf</span><span class="params">(bptree L)</span>;<span class="comment">//判断是否是叶子节点</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">find_me</span><span class="params">(bptree p)</span>;<span class="comment">//找到自己是第几个孩子</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>插入位置</strong>：由于仍然是子树比键值多一，插入函数和b树完全相同。需要说明的是，按照网站上的设置，我们将相同元素插入左子树，插入到同一个节点的重复值我们默认放在右边。</p>
</li>
<li>
<p><strong>分裂函数</strong>：除了叶子节点完全相同，叶子节点的第二个分组需要保留中位数，设待分裂节点为L</p>
<ul>
<li>
<p>在<strong>初始化子节点</strong>的时候，将bp2的大小进行一次判断，其余一致</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!isleaf(L))  bp2-&gt;datanum = (num - split);</span><br><span class="line">   <span class="keyword">else</span> &#123;bp2-&gt;datanum= (num - split + <span class="number">1</span>);  bp1-&gt;next = bp2;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>第一个分裂节点</strong>的继承完全相同，直接复用即可</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; split; i++)</span><br><span class="line">        &#123; <span class="comment">// 如果是叶子节点，孩子都为NULL，这里复用</span></span><br><span class="line">            bp1-&gt;child[i] = L-&gt;child[i];</span><br><span class="line">            <span class="keyword">if</span> (L-&gt;child[i])</span><br><span class="line">                L-&gt;child[i]-&gt;parent = bp1; </span><br><span class="line">            bp1-&gt;data[i] = L-&gt;data[i];</span><br><span class="line">            bp1-&gt;data_index[i] = L-&gt;data_index[i];</span><br><span class="line">        &#125;<span class="comment">//继承的是一个完整节点的内容即键比子树少一个</span></span><br><span class="line">        bp1-&gt;child[split] = L-&gt;child[split];</span><br><span class="line">        <span class="keyword">if</span> (L-&gt;child[split])</span><br><span class="line">            L-&gt;child[split]-&gt;parent = bp1;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>第二个分裂节点</strong>的继承需要判断是否保留 中位数的值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(!isleaf(L))&#123;</span><br><span class="line">        <span class="keyword">for</span> (i = split + <span class="number">1</span>, j = <span class="number">1</span>; i &lt;= num; i++, j++)&#123;</span><br><span class="line">            bp2-&gt;child[j] = L-&gt;child[i];</span><br><span class="line">            <span class="keyword">if</span> (L-&gt;child[i]) L-&gt;child[i]-&gt;parent = bp2;</span><br><span class="line">            bp2-&gt;data[j] = L-&gt;data[i];</span><br><span class="line">            bp2-&gt;data_index[j] = L-&gt;data_index[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (L-&gt;child[num + <span class="number">1</span>])</span><br><span class="line">            L-&gt;child[num + <span class="number">1</span>]-&gt;parent = bp2;</span><br><span class="line">        bp2-&gt;child[j] = L-&gt;child[num + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">  <span class="keyword">else</span><span class="comment">//叶子节点第二个分组多一个</span></span><br><span class="line">       <span class="keyword">for</span> (i = split, j = <span class="number">1</span>; i &lt;= num; i++, j++)    &#123; </span><br><span class="line">            bp2-&gt;data[j] = L-&gt;data[i];</span><br><span class="line">            bp2-&gt;data_index[j] = L-&gt;data_index[i];</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>判断插入位置</strong>，如果是根节点分裂，则插入位置为1，其余通过找到自己是第几个孩子，则插入位置就是第几个，原因见下一步</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!L-&gt;parent) &#123;</span><br><span class="line">            parent=L;</span><br><span class="line">            parent-&gt;datanum=<span class="number">0</span>;</span><br><span class="line">            position=<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="comment">//相当于充当头结点</span></span><br><span class="line"> <span class="keyword">else</span> &#123;  </span><br><span class="line">     parent=L-&gt;parent;</span><br><span class="line">     position=find_me(L);<span class="comment">//指针右侧，下标为position</span></span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>将<strong>中位数插入父节点</strong>，设 L是父节点的第 i个孩子，则父节点中 data[ i ] 是大于分裂子树的所有值，故我们将分裂子树的中间值插入在其之前，即从data[ i ]和child[ i+1 ]开始后移，此时 child[ i ] (原本指向L)，data[ i ]和child[ i+1]会空余出来。我们分别设置为指向分裂子节点的指针和分裂的中位数即可。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> bp1-&gt;parent = parent;</span><br><span class="line"> bp2-&gt;parent = parent;</span><br><span class="line"> <span class="keyword">for</span> (i=parent-&gt;datanum; i &gt;= position; i--) &#123;</span><br><span class="line">        parent-&gt;data[i + <span class="number">1</span>] =parent-&gt;data[i];</span><br><span class="line">        parent-&gt;data_index[i + <span class="number">1</span>] =parent-&gt;data_index[i];</span><br><span class="line">        parent-&gt;child[i + <span class="number">2</span>] =parent-&gt;child[i + <span class="number">1</span>];</span><br><span class="line">     &#125;      </span><br><span class="line">parent-&gt;data[position] = L-&gt;data[split];</span><br><span class="line">parent-&gt;data_index[position] = L-&gt;data_index[split];</span><br><span class="line">parent-&gt;child[position] = bp1;</span><br><span class="line">parent-&gt;child[position + <span class="number">1</span>] = bp2;</span><br><span class="line">parent-&gt;datanum++;</span><br><span class="line"><span class="keyword">return</span> parent; </span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><strong>整体</strong>：整体插入过程类似b树，找到叶子结点的位置后插入，如果满则进行分裂操作，同时判断向上父节点是否会满。具体内容参见不多赘述。</p>
</li>
<li>
<p>注意：next的调整在初始化，分裂和合并的时候都要用到，后续新增了pre的结构体成员用于寻找前一个节点，这里的修改片段就不列举了，具体内容参见源码。</p>
</li>
</ul>
</li>
<li>
<p>树的删除</p>
<ul>
<li>
<p>删除仅在<strong>叶子节点</strong>进行，其中比较重要的是<strong>索引的更新</strong>，由于在删除调整的时候，向右兄弟借最小数会导致右兄弟的父亲等索引变化，向右合并同理，向左借数会导致本节点最小值的变化，向左合并同理，并且我们需要用<strong>调整后节点的值来进行索引的更改</strong>，故我们并不针对具体的过程进行调整，而是在<strong>索引进行结构调整之后使用更新函数遍历读取</strong>各个右子树的最左数字。</p>
</li>
<li>
<p>辅助函数，最重要的是索引更新函数，使用递归方式将所有索引节点进行更新，就是对索引树的遍历，找到右子树最左节点进行更新即可。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">isrich</span><span class="params">(bptree p)</span>;<span class="comment">//判断是否比最低标准多一个</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">not_lower</span><span class="params">(bptree p)</span>;<span class="comment">//为1表示不需要调整，判断是否过少</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">update_index</span><span class="params">(bptree &amp;L)</span>&#123;<span class="comment">//索引的更新</span></span><br><span class="line">    bptree temp=L,q;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">if</span>(isleaf(L)) <span class="keyword">return</span>;<span class="comment">//递归子节点为叶子结束</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=L-&gt;datanum;i++)&#123;</span><br><span class="line">        temp=L-&gt;child[i+<span class="number">1</span>];<span class="comment">//找右子树的最左节点</span></span><br><span class="line">        <span class="keyword">for</span>(q,temp;temp;q=temp,temp=temp-&gt;child[<span class="number">1</span>]);<span class="comment">//一直找到q为叶子</span></span><br><span class="line">        L-&gt;data[i]=q-&gt;data[<span class="number">1</span>];</span><br><span class="line">        L-&gt;data_index[i]=q-&gt;data_index[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=L-&gt;datanum;i++) update_index(L-&gt;child[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>调整函数：和b树的调整函数不同的是，叶子节点的调整，不能借用父亲的值，而索引节点必须借用父亲的值，我们将添加判断语句来进行两者的区分，同时在之前的基础上进行简化。</p>
<ul>
<li>
<p><strong>根节点</strong>进入调整函数只有为空，此时将树根赋给唯一的一个子树即可</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(!p-&gt;parent)&#123;<span class="comment">//本节点是根节点且被删空，其他情况的根节点不需要调整，</span></span><br><span class="line">        L=p-&gt;child[<span class="number">1</span>];</span><br><span class="line">        L-&gt;parent=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>判端是否存在<strong>左右兄弟</strong>，存在即记录，我们使用的<strong>优先级</strong>和网站上相同，首先判断右兄弟是否富裕，然后左兄弟是否富裕，然后判断右兄弟是否存在。下面是大概的框架</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//void borrow_node(bptree &amp;L,bptree p,int i)</span></span><br><span class="line"><span class="comment">//判断左右兄弟是否存在</span></span><br><span class="line"><span class="keyword">if</span>(i+<span class="number">1</span>&lt;=p-&gt;parent-&gt;datanum+<span class="number">1</span>) right_bro=p-&gt;parent-&gt;child[i+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">else</span> right_bro=<span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span>(i<span class="number">-1</span>&gt;=<span class="number">1</span>) left_bro=p-&gt;parent-&gt;child[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">else</span> left_bro=<span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span>(!(right_bro&amp;&amp;isrich(right_bro))||left_bro&amp;&amp;isrich(left_bro))&#123;<span class="comment">//这一行是网站选择的优先级，先选左节点</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(left_bro)<span class="comment">//左节点是否存在</span></span><br><span class="line">            &#123;</span><br><span class="line">                 <span class="keyword">if</span>(isrich(left_bro))&#123;&#125;<span class="comment">//直接借用，不影响父节点</span></span><br><span class="line">                 <span class="keyword">else</span> &#123;&#125;<span class="comment">//合并，删除父节点</span></span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">if</span>(right_bro)<span class="comment">//同理</span></span><br><span class="line">     &#123;</span><br><span class="line">    <span class="keyword">if</span>(isrich(right_bro))&#123;&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
</li>
<li>
<p>左兄弟的借用或者合并</p>
<ul>
<li>
<p>对于非叶子节点不管走哪一步，都需要将本节点向右移动一位，然后获取父亲节点的对应元素，如果是左兄弟，且自己是第i个孩子，则父节点元素为 data[i-1]，反之为data[i]，本节点会腾出 data[1]和child[1]的位置用于放父亲的值和左兄弟的最右侧子树。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(!isleaf(p))&#123;</span><br><span class="line">      <span class="keyword">for</span>(count=p-&gt;datanum;count&gt;=<span class="number">1</span>;count--)&#123;</span><br><span class="line">              p-&gt;child[count+<span class="number">1</span>]=p-&gt;child[count];</span><br><span class="line">              p-&gt;data[count+<span class="number">1</span>]=p-&gt;data[count];</span><br><span class="line">              p-&gt;data_index[count+<span class="number">1</span>]=p-&gt;data_index[count];</span><br><span class="line">      &#125;</span><br><span class="line">          p-&gt;child[<span class="number">2</span>]=p-&gt;child[<span class="number">1</span>];<span class="comment">//指针多移动一个</span></span><br><span class="line">          p-&gt;data[<span class="number">1</span>]=p-&gt;parent-&gt;data[i<span class="number">-1</span>];</span><br><span class="line">          p-&gt;data_index[<span class="number">1</span>]=p-&gt;parent-&gt;data_index[i<span class="number">-1</span>];</span><br><span class="line">          p-&gt;child[<span class="number">1</span>]=left_bro-&gt;child[left_bro-&gt;datanum+<span class="number">1</span>];<span class="comment">//继承的是左孩子的最右边子树</span></span><br><span class="line">          <span class="keyword">if</span>(left_bro-&gt;child[left_bro-&gt;datanum+<span class="number">1</span>]) left_bro-&gt;child[left_bro-&gt;datanum+<span class="number">1</span>]-&gt;parent=p;</span><br><span class="line">          p-&gt;datanum++; </span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>判断左兄弟<strong>是否富裕</strong>，如果是，非叶子结点将<strong>左兄弟最大元素</strong>放在父亲被扯下来的元素位置上，然后直接删除左兄弟最右侧键值和指针。如果是叶子节点，则将左兄弟这俩元素直接放置在自己的第一二位，然后使用之前说的<strong>更新索引</strong>进行父节点的统一更新。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(isrich(left_bro))&#123;</span><br><span class="line">        <span class="keyword">if</span>(!isleaf(p))&#123;</span><br><span class="line">        <span class="comment">//父亲节点： 兄弟节点最左放在父亲被拉下来的位置</span></span><br><span class="line">        p-&gt;parent-&gt;data[i<span class="number">-1</span>]=left_bro-&gt;data[left_bro-&gt;datanum];</span><br><span class="line">        p-&gt;parent-&gt;data_index[i<span class="number">-1</span>]=left_bro-&gt;data_index[left_bro-&gt;datanum];</span><br><span class="line">        <span class="comment">//删除左兄弟左节点最右元素，删除都是成对删的！！！</span></span><br><span class="line">        left_bro-&gt;data[left_bro-&gt;datanum]=<span class="number">0</span>;</span><br><span class="line">        left_bro-&gt;data_index[left_bro-&gt;datanum]=<span class="number">0</span>;</span><br><span class="line">        left_bro-&gt;child[left_bro-&gt;datanum+<span class="number">1</span>]=<span class="literal">NULL</span>;</span><br><span class="line">        left_bro-&gt;datanum--;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;<span class="comment">//叶子节点会判断兄弟节点是富裕，富裕则借，不富裕则合并删父亲</span></span><br><span class="line">           <span class="keyword">for</span>(count=p-&gt;datanum;count&gt;=<span class="number">1</span>;count--)&#123;</span><br><span class="line">                p-&gt;child[count+<span class="number">1</span>]=p-&gt;child[count];</span><br><span class="line">                p-&gt;data[count+<span class="number">1</span>]=p-&gt;data[count];</span><br><span class="line">                p-&gt;data_index[count+<span class="number">1</span>]=p-&gt;data_index[count];</span><br><span class="line">        &#125;</span><br><span class="line">            p-&gt;child[<span class="number">2</span>]=p-&gt;child[<span class="number">1</span>];<span class="comment">//指针多移动一个</span></span><br><span class="line">            p-&gt;data[<span class="number">1</span>]=left_bro -&gt;data[left_bro-&gt;datanum];</span><br><span class="line">            p-&gt;data_index[<span class="number">1</span>]=left_bro -&gt;data_index[left_bro-&gt;datanum];</span><br><span class="line">            p-&gt;datanum++;</span><br><span class="line">            left_bro-&gt;data[left_bro-&gt;datanum]=<span class="number">0</span>;</span><br><span class="line">            left_bro-&gt;datanum--;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>如果不富裕和左兄弟合并，这个过程是一致的，<strong>非叶子节点</strong>本节点第一个键值是父亲，第一个指针是左兄弟的最右指针，此时左兄弟可以看成指针数和键值相同，最右侧指针可以看成被本节点抢过来了。而叶子节点并没有子树的继承要求，之前也没有进行p的移动，故直接添加即可。不管那种情况，父节点的指针和键值都是要删除的。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span>&#123;<span class="comment">//自己并入左兄弟,父节点可能会出问题</span></span><br><span class="line">        <span class="keyword">for</span>(count=left_bro-&gt;datanum+<span class="number">1</span>,p_i=<span class="number">1</span>;count&lt;=(left_bro-&gt;datanum)+(p-&gt;datanum);count++,p_i++)&#123;<span class="comment">//多移动一个</span></span><br><span class="line">            left_bro-&gt;data[count]=p-&gt;data[p_i];</span><br><span class="line">            left_bro-&gt;data_index[count]=p-&gt;data_index[p_i];</span><br><span class="line">            left_bro-&gt;child[count+<span class="number">1</span>]=p-&gt;child[p_i];</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;child[p_i])</span><br><span class="line">               p-&gt;child[p_i]-&gt;parent=left_bro;   </span><br><span class="line">        &#125;</span><br><span class="line">         left_bro-&gt;datanum+=p-&gt;datanum;</span><br><span class="line">        <span class="comment">//开始删除父亲中的元素i-1和指针i</span></span><br><span class="line">        <span class="keyword">for</span>(count=i<span class="number">-1</span>;count&lt;=p-&gt;parent-&gt;datanum;count++)&#123;</span><br><span class="line">            p-&gt;parent-&gt;data[count]=p-&gt;parent-&gt;data[count+<span class="number">1</span>];</span><br><span class="line">            p-&gt;parent-&gt;data_index[count]=p-&gt;parent-&gt;data_index[count+<span class="number">1</span>];</span><br><span class="line">            p-&gt;parent-&gt;child[count+<span class="number">1</span>]=p-&gt;parent-&gt;child[count+<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;parent-&gt;datanum--;</span><br><span class="line">        <span class="keyword">if</span>(isleaf(p)) left_bro-&gt;next=p-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(not_lower(left_bro-&gt;parent)) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">        p=left_bro-&gt;parent;</span><br><span class="line">        i=find_me(p);</span><br><span class="line">        borrow_node(L,p,i);<span class="comment">//设置好结束</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">      &#125;<span class="comment">//end if(not rich)</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>右兄弟的借用或合并，类似</p>
<ul>
<li>
<p>非叶子节点先将父节点 data[i]元素放在最右边，并且继承右兄弟的最小指针，此时右兄弟可以看成指针数少一。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(!isleaf(p))&#123;</span><br><span class="line">           p-&gt;data[p-&gt;datanum+<span class="number">1</span>]=p-&gt;parent-&gt;data[i];</span><br><span class="line">           p-&gt;data_index[p-&gt;datanum+<span class="number">1</span>]=p-&gt;parent-&gt;data_index[i];</span><br><span class="line">           p-&gt;child[p-&gt;datanum+<span class="number">2</span>]=right_bro-&gt;child[<span class="number">1</span>];</span><br><span class="line">           <span class="keyword">if</span>(right_bro-&gt;child[<span class="number">1</span>]) right_bro-&gt;child[<span class="number">1</span>]-&gt;parent=p;</span><br><span class="line">           p-&gt;datanum++;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>如果右节点富裕，非叶子节点直接将最小元素放在父亲节点上，叶子节点将右兄弟的最小值放在自己最右侧，叶子节点不需要考虑指针，直接借过来键值。然后将右兄弟的第一个键值和指针删掉即可。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(isrich(right_bro))&#123;</span><br><span class="line">           <span class="comment">// 右兄弟节点最左边放在父亲被拉下来的位置</span></span><br><span class="line">           <span class="keyword">if</span>(!isleaf(p))&#123;</span><br><span class="line">           p-&gt;parent-&gt;data[i]=right_bro-&gt;data[<span class="number">1</span>];</span><br><span class="line">           p-&gt;parent-&gt;data_index[i]=right_bro-&gt;data_index[<span class="number">1</span>];</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span> &#123;<span class="comment">//叶子节点借右兄弟的最小值</span></span><br><span class="line">               p-&gt;data[p-&gt;datanum+<span class="number">1</span>]=right_bro -&gt;data[<span class="number">1</span>];</span><br><span class="line">               p-&gt;data_index[p-&gt;datanum+<span class="number">1</span>]=right_bro -&gt;data_index[<span class="number">1</span>];</span><br><span class="line">               p-&gt;datanum++;</span><br><span class="line">              <span class="comment">// meda=right_bro-&gt;data[1];//调整索引</span></span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//删除右兄弟最左元素和指针</span></span><br><span class="line">       <span class="keyword">for</span>(count=<span class="number">1</span>;count&lt;=right_bro-&gt;datanum;count++)&#123;</span><br><span class="line">           right_bro-&gt;data[count]=right_bro-&gt;data[count+<span class="number">1</span>];</span><br><span class="line">           right_bro-&gt;data_index[count]=right_bro-&gt;data_index[count+<span class="number">1</span>];</span><br><span class="line">           right_bro-&gt;child[count]=right_bro-&gt;child[count+<span class="number">1</span>];</span><br><span class="line">       &#125;</span><br><span class="line">       right_bro-&gt;child[right_bro-&gt;datanum]=right_bro-&gt;child[right_bro-&gt;datanum+<span class="number">1</span>];</span><br><span class="line">       right_bro-&gt;child[right_bro-&gt;datanum+<span class="number">1</span>]=<span class="literal">NULL</span>;</span><br><span class="line">       right_bro-&gt;data[right_bro-&gt;datanum]=<span class="number">0</span>;</span><br><span class="line">       right_bro-&gt;datanum--;</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>和右兄弟的合并</p>
<ul>
<li>同理，由于非叶子节点可以看成已经拥有了父节点和右兄弟的最左节点，故右兄弟可以看成最没有左指针，我们直接按顺序接入右兄弟的第二个指针起的所有指针，从第一个键起的所有键（俩数目相同）。而叶子节点只需要考虑将右兄弟的键值全部并过来即可。然后同样的父亲节点都要删除</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> dis=<span class="number">1</span>;<span class="comment">//我们把右节点并入自己</span></span><br><span class="line">       <span class="keyword">for</span>(count=p-&gt;datanum+<span class="number">1</span>,dis;dis&lt;=right_bro-&gt;datanum;dis++,count++)&#123;</span><br><span class="line">           p-&gt;data[count]=right_bro-&gt;data[dis];</span><br><span class="line">           p-&gt;data_index[count]=right_bro-&gt;data_index[dis];</span><br><span class="line">           p-&gt;child[count]=right_bro-&gt;child[dis];</span><br><span class="line">           <span class="keyword">if</span>(right_bro-&gt;child[dis]) right_bro-&gt;child[dis]-&gt;parent=p;</span><br><span class="line">       &#125;</span><br><span class="line">     p-&gt;child[count]=right_bro-&gt;child[dis];<span class="comment">//指针比数据要多一个</span></span><br><span class="line">     <span class="keyword">if</span>(right_bro-&gt;child[dis]) right_bro-&gt;child[dis]-&gt;parent=p;</span><br><span class="line">     p-&gt;datanum+=right_bro-&gt;datanum;</span><br><span class="line">   <span class="comment">//将父节点的指针进行删除，即i+1和元素i</span></span><br><span class="line">       <span class="keyword">for</span>(count=i;count&lt;=p-&gt;parent-&gt;datanum;count++)&#123;</span><br><span class="line">           p-&gt;parent-&gt;data[count]=p-&gt;parent-&gt;data[count+<span class="number">1</span>];</span><br><span class="line">           p-&gt;parent-&gt;data_index[count]=p-&gt;parent-&gt;data_index[count+<span class="number">1</span>];</span><br><span class="line">           p-&gt;parent-&gt;child[count+<span class="number">1</span>]=p-&gt;parent-&gt;child[count+<span class="number">2</span>];</span><br><span class="line">       &#125;</span><br><span class="line">       p-&gt;parent-&gt;datanum--;</span><br><span class="line">     <span class="comment">//  delete p;//原本的节点删除</span></span><br><span class="line">      <span class="keyword">if</span>(isleaf(p))p-&gt;next=right_bro-&gt;next;<span class="comment">//叶子节点串起来</span></span><br><span class="line">   <span class="comment">//考虑特殊情况，父节点是根节点且被删空，继续调用本函数，返回到这里直接return不会继续回溯</span></span><br><span class="line">       <span class="keyword">if</span>(not_lower(right_bro-&gt;parent)) <span class="keyword">return</span>;</span><br><span class="line">       <span class="keyword">else</span> &#123;</span><br><span class="line">       p=right_bro-&gt;parent;</span><br><span class="line">       <span class="comment">//父亲是父亲的父亲的第几个孩子!!!!可能出问题</span></span><br><span class="line">       i=find_me(p);</span><br><span class="line">       borrow_node(L,p,i);</span><br><span class="line">       &#125;  </span><br><span class="line">        <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>最后是向上调整，直接按照之前的方法，在合并之后判断父节点数量，少则递归，不少则返回，一定要返回，不然本轮可能结束不了。</p>
</li>
</ul>
</li>
<li>
<p>树的搜索，和之前的搜索不同，在判断的时候需要加上一个处于叶子节点的判断条件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">search_node</span><span class="params">(bptree L, <span class="type">float</span> temp, bptree result[],<span class="type">int</span> id[], <span class="type">int</span> &amp;resultnum)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j;<span class="comment">//如果需要返回节点中的第几个元素的话，可以将返回的id换成i</span></span><br><span class="line">    <span class="keyword">if</span> (!L) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(flag&amp;&amp;resultnum) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(isleaf(L))&#123;<span class="comment">//除了叶子节点都是索引,只进行下面的索引</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=L-&gt;datanum;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (L-&gt;data[i] == temp) &#123;</span><br><span class="line">            result[resultnum] = L;id[resultnum++]=L-&gt;data_index[i];</span><br><span class="line">            <span class="keyword">if</span>(flag) <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    大于等于都放在右子树但是由于分裂等操作，等于的两边可能都有</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= L-&gt;datanum ; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (temp &lt;= L-&gt;data[j])</span><br><span class="line">        &#123; </span><br><span class="line">            search_node(L-&gt;child[j], temp, result,id,resultnum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     search_node(L-&gt;child[L-&gt;datanum+<span class="number">1</span>],temp,result,id,resultnum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="实验结果-2"><strong>实验结果</strong></h4>
<ol>
<li>
<p>树的建立</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="assets/image-20221105170745878.png" alt="image-20221105170745878" style="zoom:67%;" />
</li>
<li>
<p>搜索</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="assets/image-20221105170828496.png" alt="image-20221105170828496" style="zoom:67%;" />
</li>
<li>
<p>删除22</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="assets/image-20221105170900517.png" alt="image-20221105170900517" style="zoom:67%;" />
</li>
<li>
<p>插入15</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="assets/image-20221105170924215.png" alt="image-20221105170924215" style="zoom:67%;" />
</li>
</ol>
<h4 id="实验感想"><strong>实验感想</strong></h4>
<ul>
<li>检查过程中的错误
<ul>
<li>在b+树中，对于自己并入左兄弟的情况，并没有把第一个子树的parent设置好</li>
<li>b树中，对于后续删空情况，并没有设置好新的头结点的parent=NULL</li>
</ul>
</li>
</ul>
<h4 id="时间复杂度分析-4"><strong>时间复杂度分析</strong></h4>
<p>和b树的分析类似，只是所有的结果都落在叶子节点，和树高有关。</p>
<p>M阶B+树搜索插入删除的时间复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mi>M</mi></msub><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(log_MN)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></p>
<h3 id="试验测试">试验测试</h3>
<p>测试内容现场检查过，直接运行可以再次检查，此处不多赘述。</p>
<h3 id="时间复杂度比较">时间复杂度比较</h3>
<ul>
<li>在试验进行过程中就有一个直观的感觉，二叉树中平衡树比红黑树要要求严格，红黑树比搜索树要求严格。而b树和b+树阶数本身更高，树会更矮，相同数量的b+树显然会更宽。这里我们利用实验的函数进行时间的测量。（并未保留在源码中）</li>
<li>理论上的时间复杂度分析在上面，我们仅从固定规模的元素出发进行<strong>直观上的比较</strong></li>
<li>另外需要将result数组更改数组规模更大，不过<strong>更加建议把flag改成1</strong>，也就不需要担心重复的数过多的问题了。</li>
<li>实验规模如下表所示，生成数字在1-10000之间</li>
</ul>
<p>二叉树</p>
<table>
<thead>
<tr>
<th>测试内容</th>
<th>时间</th>
</tr>
</thead>
<tbody>
<tr>
<td>插入1000 删除950</td>
<td>0.008s</td>
</tr>
<tr>
<td>插入10000 删除9950</td>
<td>0.04s</td>
</tr>
<tr>
<td>插入50000 删除49950</td>
<td>0.047s</td>
</tr>
<tr>
<td>插入100000删除99950</td>
<td>0.803s</td>
</tr>
<tr>
<td>插入500000删除499950</td>
<td>7.086s</td>
</tr>
</tbody>
</table>
<p>平衡树</p>
<table>
<thead>
<tr>
<th>测试内容</th>
<th>时间</th>
</tr>
</thead>
<tbody>
<tr>
<td>插入1000 删除950</td>
<td>0.139s</td>
</tr>
<tr>
<td>1插入10000 删除9950</td>
<td>21.621s</td>
</tr>
<tr>
<td>1插入50000 删除49950</td>
<td>234.598s</td>
</tr>
<tr>
<td>插入100000删除99950</td>
<td>356.78s</td>
</tr>
<tr>
<td>s插入500000删除499950</td>
<td>-</td>
</tr>
</tbody>
</table>
<p>红黑树</p>
<table>
<thead>
<tr>
<th>测试内容</th>
<th>时间</th>
</tr>
</thead>
<tbody>
<tr>
<td>插入1000 删除950</td>
<td>0s</td>
</tr>
<tr>
<td>插入10000 删除9950</td>
<td>0.04s</td>
</tr>
<tr>
<td>插入50000 删除49950</td>
<td>0.184s</td>
</tr>
<tr>
<td>插入100000删除99950</td>
<td>0.952s</td>
</tr>
<tr>
<td>插入500000删除499950</td>
<td>5.608s</td>
</tr>
</tbody>
</table>
<p>b树</p>
<table>
<thead>
<tr>
<th>测试内容</th>
<th>时间</th>
</tr>
</thead>
<tbody>
<tr>
<td>插入1000 删除950</td>
<td>0s</td>
</tr>
<tr>
<td>插入10000 删除9950</td>
<td>0.016s</td>
</tr>
<tr>
<td>插入50000 删除49950</td>
<td>0.177s</td>
</tr>
<tr>
<td>插入100000删除99950</td>
<td>0.275s</td>
</tr>
<tr>
<td>插入500000删除499950</td>
<td>1.899s</td>
</tr>
</tbody>
</table>
<p>b+树</p>
<table>
<thead>
<tr>
<th>测试内容</th>
<th>时间</th>
</tr>
</thead>
<tbody>
<tr>
<td>插入1000 删除950</td>
<td>0.008s</td>
</tr>
<tr>
<td>插入10000 删除9950</td>
<td>1.796s</td>
</tr>
<tr>
<td>插入50000 删除49950</td>
<td>46.9s</td>
</tr>
<tr>
<td>插入100000删除99950</td>
<td>76.74s</td>
</tr>
<tr>
<td>插入500000删除499950</td>
<td>226.3s</td>
</tr>
</tbody>
</table>
<blockquote>
<p>b+和b的速度访问的差距，猜想是b+每次都需要进行到叶子结点，并且函数实现的过于繁琐。</p>
</blockquote>
<p><strong>总结</strong></p>
<ul>
<li>二叉搜索树在数据数量较大时，搜索的代价也较大</li>
<li>由于进行的实验仅仅是一个函数性能的测试，并不能直接说明算法本身的快慢，有的算法实在是因为我实现的比较差，繁琐，所以展现的并不好，尤其是平衡树和b+树，使用了过多递归函数，大的数据会跑很久，当然我的电脑配置也并不是很好。</li>
<li>初次学习，如有错误，还望指正，谢谢。</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://a-624.github.io">A-624</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://a-624.github.io/post/9a359988.html">https://a-624.github.io/post/9a359988.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://a-624.github.io" target="_blank">Ann の 小窝</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%A0%91/">树</a></div><div class="post_share"><div class="social-share" data-image="https://w.wallhaven.cc/full/gp/wallhaven-gpzve7.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/36878.html"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2022/10/01/Z2cQpehGgr4qHls.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">生成式AI应用</div></div></a></div><div class="next-post pull-right"><a href="/post/a4f19052.html"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/pinkcloud.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">OS部分题目</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">实验题目： 平衡树搜索性能比较</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E7%9B%AE%E7%9A%84"><span class="toc-number">1.1.</span> <span class="toc-text">实验目的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E5%86%85%E5%AE%B9"><span class="toc-number">1.2.</span> <span class="toc-text">实验内容</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E8%AF%B4%E6%98%8E"><span class="toc-number">1.2.1.</span> <span class="toc-text">实验说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E7%94%A8%E5%87%BD%E6%95%B0%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.2.2.</span> <span class="toc-text">通用函数介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%B8%80%EF%BC%89%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-number">1.2.3.</span> <span class="toc-text">（一）二叉搜索树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E8%A6%81%E6%B1%82%EF%BC%9A"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">实验要求：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E5%86%85%E5%AE%B9%EF%BC%9A"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">实验内容：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E6%95%88%E6%9E%9C"><span class="toc-number">1.2.3.3.</span> <span class="toc-text">实验效果</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90"><span class="toc-number">1.2.3.4.</span> <span class="toc-text">时间复杂度分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%BA%8C%EF%BC%89AVL%E6%A0%91"><span class="toc-number">1.2.4.</span> <span class="toc-text">（二）AVL树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E8%A6%81%E6%B1%82%EF%BC%9A-2"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">实验要求：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E5%86%85%E5%AE%B9%EF%BC%9A-2"><span class="toc-number">1.2.4.2.</span> <span class="toc-text">实验内容：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E6%95%88%E6%9E%9C%EF%BC%9A"><span class="toc-number">1.2.4.3.</span> <span class="toc-text">实验效果：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-2"><span class="toc-number">1.2.4.4.</span> <span class="toc-text">时间复杂度分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%B8%89%EF%BC%89%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="toc-number">1.2.5.</span> <span class="toc-text">（三）红黑树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E8%A6%81%E6%B1%82%EF%BC%9A-3"><span class="toc-number">1.2.5.1.</span> <span class="toc-text">实验要求：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E5%86%85%E5%AE%B9%EF%BC%9A-3"><span class="toc-number">1.2.5.2.</span> <span class="toc-text">实验内容：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E7%BB%93%E6%9E%9C%EF%BC%9A"><span class="toc-number">1.2.5.3.</span> <span class="toc-text">实验结果：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E5%9B%9B%EF%BC%89b%E6%A0%91"><span class="toc-number">1.2.6.</span> <span class="toc-text">（四）b树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E8%A6%81%E6%B1%82"><span class="toc-number">1.2.6.1.</span> <span class="toc-text">实验要求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E8%BF%87%E7%A8%8B"><span class="toc-number">1.2.6.2.</span> <span class="toc-text">实验过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E7%BB%93%E6%9E%9C"><span class="toc-number">1.2.6.3.</span> <span class="toc-text">实验结果</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E6%84%9F%E6%83%B3%EF%BC%9A"><span class="toc-number">1.2.6.4.</span> <span class="toc-text">实验感想：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-3"><span class="toc-number">1.2.6.5.</span> <span class="toc-text">时间复杂度分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E4%BA%94%EF%BC%89b-%E6%A0%91"><span class="toc-number">1.2.7.</span> <span class="toc-text">（五）b+树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E8%A6%81%E6%B1%82-2"><span class="toc-number">1.2.7.1.</span> <span class="toc-text">实验要求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E8%BF%87%E7%A8%8B-2"><span class="toc-number">1.2.7.2.</span> <span class="toc-text">实验过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E7%BB%93%E6%9E%9C-2"><span class="toc-number">1.2.7.3.</span> <span class="toc-text">实验结果</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%AA%8C%E6%84%9F%E6%83%B3"><span class="toc-number">1.2.7.4.</span> <span class="toc-text">实验感想</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-4"><span class="toc-number">1.2.7.5.</span> <span class="toc-text">时间复杂度分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%95%E9%AA%8C%E6%B5%8B%E8%AF%95"><span class="toc-number">1.2.8.</span> <span class="toc-text">试验测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%AF%94%E8%BE%83"><span class="toc-number">1.2.9.</span> <span class="toc-text">时间复杂度比较</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By A-624</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="聊天"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="fa-solid fa-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="fa-solid fa-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="fa-solid fa-arrow-rotate-right"></i></div><div class="rightMenu-item" id="menu-home"><i class="fa-solid fa-house"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" href="/categories/"><i class="fa-solid fa-folder-open"></i><span>文章分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="fa-solid fa-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuNormal"><div class="rightMenu-item" id="menu-translate"><i class="fa-solid fa-earth-asia"></i><span>繁简切换</span></div><div class="rightMenu-item" id="menu-darkmode"><i class="fa-solid fa-moon"></i><span>切换模式</span></div><div class="rightMenu-item" id="menu-print"><i class="fa-solid fa-print fa-fw"></i><span>打印页面</span></div></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/algoliasearch/dist/algoliasearch-lite.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instantsearch.js/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js"></script><script async="async">var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> {preloader.endLoading()})
setTimeout(function(){preloader.endLoading();}, 20000)
document.getElementById('loading-box').addEventListener('click',()=> {preloader.endLoading()})</script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'jlgkfToE73FxTz8kyHsmvdzb-gzGzoHsz',
      appKey: 'NN6nCIT47fGwz5Q1UyvFcGKP',
      avatar: 'retro',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script defer src="https://npm.elemecdn.com/jquery@latest/dist/jquery.min.js"></script><script defer data-pjax src="/js/rightMenu.js"></script><script src="https://unpkg.com/swiper/swiper-bundle.min.js"></script><script src="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-card-history/baiduhistory/js/main.js"></script><script id="canvas_nest" defer="defer" color="0,0,0" opacity="0.3" zIndex="-1" count="99" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="//code.tidio.co/hc1ohlstnc9iscgzcgzmy7ybiyyxsvnx.js" async="async"></script><script>function onTidioChatApiReady() {
  window.tidioChatApi.hide();
  window.tidioChatApi.on("close", function() {
    window.tidioChatApi.hide();
  });
}
if (window.tidioChatApi) {
  window.tidioChatApi.on("ready", onTidioChatApiReady);
} else {
  document.addEventListener("tidioChat-ready", onTidioChatApiReady);
}

var chatBtnFn = () => {
  document.getElementById("chat_btn").addEventListener("click", function(){
    window.tidioChatApi.show();
    window.tidioChatApi.open();
  });
}
chatBtnFn()
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script data-pjax>
    function butterfly_categories_card_injector_config(){
      var parent_div_git = document.getElementById('recent-posts');
      var item_html = '<style>li.categoryBar-list-item{width:32.3%;}.categoryBar-list{max-height: 190px;overflow:auto;}.categoryBar-list::-webkit-scrollbar{width:0!important}@media screen and (max-width: 650px){.categoryBar-list{max-height: 160px;}}</style><div class="recent-post-item" style="height:auto;width:100%;padding:0px;"><div id="categoryBar"><ul class="categoryBar-list"><li class="categoryBar-list-item" style="background:url(https://s2.loli.net/2022/11/06/zEXFSDwsGMpxf3R.png);"> <a class="categoryBar-list-link" href="categories/notebook/">notebook</a><span class="categoryBar-list-count">6</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://s2.loli.net/2022/11/06/eLUA2PoIQBfu3hS.png);"> <a class="categoryBar-list-link" href="categories/tool/">tool</a><span class="categoryBar-list-count">3</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://s2.loli.net/2022/11/06/lgYVqNypjRCe3d2.png);"> <a class="categoryBar-list-link" href="categories/coding/">coding</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://s2.loli.net/2022/11/06/BQZan4FDflVe1t2.png);"> <a class="categoryBar-list-link" href="categories/blog/">blog</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://s2.loli.net/2022/11/06/9lDYIQiJGjkaM1L.png);"> <a class="categoryBar-list-link" href="categories/experiment/">experiment</a><span class="categoryBar-list-count">3</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://s2.loli.net/2022/11/06/ZnRYVAI598EGQ7X.png);"> <a class="categoryBar-list-link" href="categories/实验室/">实验室</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(undefined);"> <a class="categoryBar-list-link" href="categories/expriment/">expriment</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(undefined);"> <a class="categoryBar-list-link" href="categories/bibi/">bibi</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li></ul></div></div>';
      console.log('已挂载butterfly_categories_card')
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      }
    if( document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    butterfly_categories_card_injector_config()
    }
  </script><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="post/1563.html" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2022/10/01/p6CQoLxsIWcu5zq.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2022-08-31</span><a class="blog-slider__title" href="post/1563.html" alt="">md公式输入语法</a><div class="blog-slider__text">常用的公式输入方法</div><a class="blog-slider__button" href="post/1563.html" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="post/6bfa58f8.html" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2022/08/14/r5bqM3IHz2w9smc.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2022-10-26</span><a class="blog-slider__title" href="post/6bfa58f8.html" alt="">C 与数据结构</a><div class="blog-slider__text">c语言知识整合</div><a class="blog-slider__button" href="post/6bfa58f8.html" alt="">详情   </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = '/';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><script data-pjax src="https://npm.elemecdn.com/hexo-filter-gitcalendar/lib/gitcalendar.js"></script><script data-pjax>
  function gitcalendar_injector_config(){
      var parent_div_git = document.getElementById('recent-posts');
      var item_html = '<div class="recent-post-item" style="width:100%;height:auto;padding:10px;"><style>#git_container{min-height: 280px}@media screen and (max-width:650px) {#git_container{min-height: 0px}}</style><div id="git_loading" style="width:10%;height:100%;margin:0 auto;display: block;"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 50 50" style="enable-background:new 0 0 50 50" xml:space="preserve"><path fill="#d0d0d0" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z" transform="rotate(275.098 25 25)"><animatetransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animatetransform></path></svg><style>#git_container{display: none;}</style></div><div id="git_container"></div></div>';
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      console.log('已挂载gitcalendar')
      }

    if( document.getElementById('recent-posts') && (location.pathname ==='/about/'|| '/about/' ==='all')){
        gitcalendar_injector_config()
        GitCalendarInit("https://calendar-a-624.vercel.app/api?A-624",['rgb(145, 145, 145, 0.2)', '#c6ecc1', '#a0e2bb', '#1fc7b6', '#70c5d3', '#60a2ce', '#507ac9', '#4356c5', '#423cc4', '#5b3abc', '#7138b6'],'A-624')
    }
  </script><!-- hexo injector body_end end --></body></html>